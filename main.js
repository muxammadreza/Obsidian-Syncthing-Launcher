/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tree-kill/index.js
var require_tree_kill = __commonJS({
  "node_modules/tree-kill/index.js"(exports, module2) {
    "use strict";
    var childProcess = require("child_process");
    var spawn2 = childProcess.spawn;
    var exec2 = childProcess.exec;
    module2.exports = function(pid, signal, callback) {
      if (typeof signal === "function" && callback === void 0) {
        callback = signal;
        signal = void 0;
      }
      pid = parseInt(pid);
      if (Number.isNaN(pid)) {
        if (callback) {
          return callback(new Error("pid must be a number"));
        } else {
          throw new Error("pid must be a number");
        }
      }
      var tree = {};
      var pidsToProcess = {};
      tree[pid] = [];
      pidsToProcess[pid] = 1;
      switch (process.platform) {
        case "win32":
          exec2("taskkill /pid " + pid + " /T /F", callback);
          break;
        case "darwin":
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn2("pgrep", ["-P", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
        default:
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn2("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
      }
    };
    function killAll(tree, signal, callback) {
      var killed = {};
      try {
        Object.keys(tree).forEach(function(pid) {
          tree[pid].forEach(function(pidpid) {
            if (!killed[pidpid]) {
              killPid(pidpid, signal);
              killed[pidpid] = 1;
            }
          });
          if (!killed[pid]) {
            killPid(pid, signal);
            killed[pid] = 1;
          }
        });
      } catch (err) {
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        return callback();
      }
    }
    function killPid(pid, signal) {
      try {
        process.kill(parseInt(pid, 10), signal);
      } catch (err) {
        if (err.code !== "ESRCH")
          throw err;
      }
    }
    function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
      var ps = spawnChildProcessesList(parentPid);
      var allData = "";
      ps.stdout.on("data", function(data) {
        var data = data.toString("ascii");
        allData += data;
      });
      var onClose = function(code) {
        delete pidsToProcess[parentPid];
        if (code != 0) {
          if (Object.keys(pidsToProcess).length == 0) {
            cb();
          }
          return;
        }
        allData.match(/\d+/g).forEach(function(pid) {
          pid = parseInt(pid, 10);
          tree[parentPid].push(pid);
          tree[pid] = [];
          pidsToProcess[pid] = 1;
          buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
        });
      };
      ps.on("close", onClose);
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyncthingLauncher
});
module.exports = __toCommonJS(main_exports);
var http = __toESM(require("http"));
var import_obsidian = require("obsidian");
var import_events = require("events");
var spawn;
var exec;
var readFileSync;
var writeFileSync;
try {
  const childProcess = require("child_process");
  const fs = require("fs");
  spawn = childProcess.spawn;
  exec = childProcess.exec;
  readFileSync = fs.readFileSync;
  writeFileSync = fs.writeFileSync;
} catch (error) {
  console.log("Desktop-only modules not available (mobile platform detected)");
}
var DEFAULT_SETTINGS = {
  syncthingApiKey: "",
  vaultFolderID: "",
  startOnObsidianOpen: false,
  stopOnObsidianClose: false,
  useDocker: false,
  remoteUrl: "http://127.0.0.1:8384",
  mobileMode: false
};
var SyncthingMonitor = class extends import_events.EventEmitter {
  constructor() {
    super(...arguments);
    this.token = null;
    this.timeout = 1;
    this.isTokenSet = false;
    this.baseUrl = "http://127.0.0.1:8384";
    this.status = "idle";
    this.connectedDevicesCount = 0;
    this.availableDevices = 0;
    this.setStatusIcon = () => {
    };
  }
  startMonitoring(settings, setStatusIcon, baseUrl) {
    this.token = settings.syncthingApiKey;
    this.timeout = 1;
    this.setStatusIcon = setStatusIcon;
    this.isTokenSet = !!settings.syncthingApiKey;
    this.baseUrl = baseUrl;
    if (this.isTokenSet) {
      this.poll();
      this.checkConnections();
    } else {
      this.status = "API key not set";
      this.setStatusIcon("\u274C");
      this.emit("status-update", {
        status: this.status,
        fileCompletion: NaN,
        globalItems: NaN,
        needItems: NaN,
        connectedDevicesCount: NaN,
        availableDevices: NaN
      });
    }
  }
  stopMonitoring() {
    if (this.pollingTimeoutId) {
      clearTimeout(this.pollingTimeoutId);
      this.pollingTimeoutId = void 0;
    }
    this.lastEventId = void 0;
    this.status = "stopped";
    this.emit("disconnected");
  }
  poll() {
    var _a;
    const lastId = (_a = this.lastEventId) != null ? _a : 0;
    if (!this.token) {
      console.error("Syncthing API token is not set. Cannot poll for events.");
      this.status = "API key not set";
      this.emit("status-update", {
        status: this.status,
        fileCompletion: NaN,
        globalItems: NaN,
        needItems: NaN,
        connectedDevicesCount: NaN,
        availableDevices: NaN
      });
      return;
    }
    const url = new URL(this.baseUrl);
    let hostname = url.hostname;
    if (hostname === "localhost" || hostname === "127.0.0.1") {
      hostname = "::1";
    }
    const options = {
      hostname,
      port: parseInt(url.port) || 8384,
      path: `/rest/events?since=${lastId}&timeout=${this.timeout}`,
      method: "GET",
      headers: {
        "X-API-Key": this.token
      }
    };
    const req = http.request(options, (res) => {
      let body = "";
      res.on("data", (chunk) => {
        body += chunk;
      });
      res.on("end", () => {
        var _a2;
        const csrfErrorRegex = /CSRF Error/i;
        if (res.statusCode === 401 || csrfErrorRegex.test(body)) {
          console.error("Syncthing API key is invalid (401 Unauthorized or CSRF Error).");
          this.status = "Invalid API key";
          this.setStatusIcon("\u274C");
          this.emit("status-update", {
            status: this.status,
            fileCompletion: NaN,
            globalItems: NaN,
            needItems: NaN,
            connectedDevicesCount: NaN,
            availableDevices: NaN
          });
          this.pollingTimeoutId = setTimeout(() => this.poll(), 5e3);
          return;
        }
        try {
          const events = JSON.parse(body);
          if (Array.isArray(events)) {
            for (const event of events) {
              this.lastEventId = Math.max((_a2 = this.lastEventId) != null ? _a2 : 0, event.id);
              this.processEvent(event);
            }
          }
        } catch (err) {
          console.error("Failed to parse Syncthing events or unexpected response:", err);
        } finally {
          this.checkConnections();
          this.emit("status-update", {
            status: this.status,
            fileCompletion: this.fileCompletion,
            globalItems: this.globalItems,
            needItems: this.needItems,
            connectedDevicesCount: this.connectedDevicesCount,
            availableDevices: this.availableDevices
          });
          this.pollingTimeoutId = setTimeout(() => this.poll(), this.timeout * 1e3);
        }
      });
    });
    req.on("error", (err) => {
      console.error("Syncthing connection error:", err);
      this.status = "Connection error";
      this.setStatusIcon("\u274C");
      this.pollingTimeoutId = setTimeout(() => this.poll(), 5e3);
    });
    req.end();
  }
  processEvent(event) {
    console.log("Syncthing event:", event.type, event.data);
    switch (event.type) {
      case "FolderCompletion":
        const completion = event.data.completion;
        const globalItems = event.data.globalItems;
        const needItems = event.data.needItems;
        this.fileCompletion = completion;
        this.globalItems = globalItems;
        this.needItems = needItems;
        if (completion !== 100) {
          this.setStatusIcon("\u{1F7E1}");
        } else {
          this.setStatusIcon("\u{1F7E2}");
        }
        break;
      case "StateChanged":
        const newStatus = event.data.to;
        this.status = newStatus;
        if (newStatus === "scanning") {
          this.setStatusIcon("\u{1F7E1}");
        } else if (newStatus === "idle") {
          this.setStatusIcon("\u{1F7E2}");
        }
        break;
      case "DeviceDisconnected":
        this.setStatusIcon("\u{1F534}");
        this.status = "Device disconnected";
        break;
      case "DeviceConnected":
        this.setStatusIcon("\u{1F7E2}");
        this.status = "Device connected";
        break;
      default:
        break;
    }
  }
  checkConnections() {
    if (!this.token) {
      console.error("Syncthing API token is not set. Cannot check connections.");
      this.status = "API key not set";
      this.emit("status-update", {
        status: this.status,
        fileCompletion: NaN,
        globalItems: NaN,
        needItems: NaN,
        connectedDevicesCount: NaN,
        availableDevices: NaN
      });
      return;
    }
    const url = new URL(this.baseUrl);
    let hostname = url.hostname;
    if (hostname === "localhost" || hostname === "127.0.0.1") {
      hostname = "::1";
    }
    const options = {
      hostname,
      port: parseInt(url.port) || 8384,
      path: "/rest/system/connections",
      method: "GET",
      headers: {
        "X-API-Key": this.token
      }
    };
    const req = http.request(options, (res) => {
      let body = "";
      res.on("data", (chunk) => {
        body += chunk;
      });
      res.on("end", () => {
        const csrfErrorRegex = /CSRF Error/i;
        if (res.statusCode === 401 || csrfErrorRegex.test(body)) {
          console.error("Syncthing API key is invalid (401 Unauthorized or CSRF Error).");
          this.status = "Invalid API key";
          return;
        }
        try {
          const data = JSON.parse(body);
          const connectionsArray = Object.values(data.connections);
          this.availableDevices = connectionsArray.length;
          this.connectedDevicesCount = connectionsArray.filter((conn) => conn.connected).length;
          if (this.connectedDevicesCount === 0) {
            this.setStatusIcon("\u{1F534}");
            this.status = "No devices connected";
          } else if (this.status === "idle") {
            this.setStatusIcon("\u{1F7E2}");
          }
        } catch (err) {
          console.error("Failed to parse Syncthing connections or unexpected response:", err);
        } finally {
          this.emit("status-update", {
            status: this.status,
            fileCompletion: this.fileCompletion,
            globalItems: this.globalItems,
            needItems: this.needItems,
            connectedDevicesCount: this.connectedDevicesCount,
            availableDevices: this.availableDevices
          });
        }
      });
    });
    req.on("error", (err) => {
      console.error("Syncthing connections API error:", err);
    });
    req.end();
  }
  /**
   * Check if Syncthing is running using Node.js HTTP requests
   */
  async isSyncthingRunning() {
    return new Promise((resolve) => {
      const url = new URL(this.baseUrl);
      let hostname = url.hostname;
      if (hostname === "localhost") {
        hostname = "127.0.0.1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: "/",
        method: "GET",
        timeout: 2e3
        // 2 second timeout
      };
      const req = http.request(options, (res) => {
        resolve(true);
      });
      req.on("error", (err) => {
        console.log("Syncthing connection error:", err.message);
        if (err.message.includes("ECONNREFUSED")) {
          resolve(false);
        } else {
          resolve(false);
        }
      });
      req.on("timeout", () => {
        req.destroy();
        resolve(false);
      });
      req.end();
    });
  }
};
var UPDATE_INTERVAL = 5e3;
var SYNCTHING_CORS_PROXY_CONTAINER_URL = "http://127.0.0.1:8380/";
var SyncthingLauncher = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.vaultPath = "";
    this.vaultName = "";
    this.isMobile = false;
    this.syncthingInstance = null;
    this.syncthingLastSyncDate = "no data";
    this.statusBarConnectionIconItem = this.addStatusBarItem();
    this.statusBarLastSyncTextItem = this.addStatusBarItem();
    this.setStatusIcon = (icon) => {
      if (this.statusBarConnectionIconItem) {
        this.statusBarConnectionIconItem.setText(icon);
        let tooltip = `Syncthing: ${this.monitor.status}`;
        if (this.monitor.availableDevices > 0) {
          tooltip += `
Devices: ${this.monitor.connectedDevicesCount}/${this.monitor.availableDevices}`;
        }
        if (this.monitor.fileCompletion !== void 0 && !isNaN(this.monitor.fileCompletion)) {
          tooltip += `
Sync: ${this.monitor.fileCompletion.toFixed(1)}%`;
        }
        this.statusBarConnectionIconItem.setAttribute("title", tooltip);
        this.statusBarConnectionIconItem.ariaLabel = tooltip;
      }
    };
  }
  async onload() {
    var _a, _b, _c;
    await this.loadSettings();
    this.monitor = new SyncthingMonitor();
    this.isMobile = this.detectMobilePlatform();
    if (this.isMobile && !this.settings.mobileMode) {
      this.settings.mobileMode = true;
      await this.saveSettings();
    }
    let adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      this.vaultPath = adapter.getBasePath();
      this.vaultName = adapter.getName();
    }
    (_a = this.statusBarConnectionIconItem) == null ? void 0 : _a.addClasses(["status-bar-item", "status-icon"]);
    (_b = this.statusBarConnectionIconItem) == null ? void 0 : _b.setAttribute("data-tooltip-position", "top");
    (_c = this.statusBarConnectionIconItem) == null ? void 0 : _c.onClickEvent((event) => {
      this.monitor.isSyncthingRunning().then(
        (isRunning) => {
          if (!isRunning) {
            new import_obsidian.Notice("Starting Syncthing!");
            this.startSyncthing();
          } else {
            new import_obsidian.Notice("Stopping Syncthing!");
            this.stopSyncthing();
          }
        }
      );
    });
    this.startStatusMonitoring();
    this.updateStatusBar();
    this.registerInterval(
      window.setInterval(() => this.updateLastSyncDate(), UPDATE_INTERVAL)
    );
    this.addSettingTab(new SettingTab(this.app, this));
    if (this.settings.startOnObsidianOpen) {
      this.startSyncthing();
    }
    window.addEventListener("beforeunload", this.handleBeforeUnload.bind(this));
  }
  onunload() {
    window.removeEventListener("beforeunload", this.handleBeforeUnload.bind(this));
    this.monitor.stopMonitoring();
  }
  // --- Logic ---
  startStatusMonitoring() {
    if (!this.settings.syncthingApiKey) {
      this.setStatusIcon("\u274C");
      console.log("No API key set, skipping status monitoring");
      return;
    }
    const baseUrl = this.getSyncthingURL();
    this.monitor.startMonitoring(this.settings, this.setStatusIcon, baseUrl);
    this.monitor.on("status-update", (data) => {
      this.updateStatusBarFromMonitor(data);
    });
  }
  updateStatusBarFromMonitor(data) {
    if (data.status === "Invalid API key") {
      this.setStatusIcon("\u274C");
    } else if (data.status === "API key not set") {
      this.setStatusIcon("\u274C");
    } else if (data.connectedDevicesCount === 0) {
      this.setStatusIcon("\u{1F534}");
    } else if (data.status === "scanning") {
      this.setStatusIcon("\u{1F7E1}");
    } else if (data.fileCompletion !== void 0 && data.fileCompletion < 100) {
      this.setStatusIcon("\u{1F7E1}");
    } else {
      this.setStatusIcon("\u{1F7E2}");
    }
  }
  handleBeforeUnload(event) {
    if (this.settings.stopOnObsidianClose) {
      this.stopSyncthing();
    }
  }
  async startSyncthing() {
    this.monitor.isSyncthingRunning().then(async (isRunning) => {
      if (isRunning) {
        console.log("Syncthing is already running");
        return;
      }
      if (this.isMobile || this.settings.mobileMode) {
        new import_obsidian.Notice("Mobile mode: Please connect to an existing Syncthing instance via Remote URL in settings", 5e3);
        return;
      }
      if (this.settings.useDocker) {
        if (this.checkDockerStatus()) {
          new import_obsidian.Notice("Starting Docker");
          this.startSyncthingDockerStack();
        }
      } else {
        if (!spawn) {
          new import_obsidian.Notice("Local Syncthing execution not available on mobile platforms", 5e3);
          return;
        }
        const executableExists = await this.checkExecutableExists();
        if (!executableExists) {
          new import_obsidian.Notice("Syncthing executable missing. Attempting to download...", 5e3);
          const downloadSuccess = await this.downloadSyncthingExecutable();
          if (!downloadSuccess) {
            new import_obsidian.Notice("Auto-download failed. Please manually download syncthing-executables.tar.gz from the GitHub release or enable Mobile Mode.", 15e3);
            return;
          }
        }
        const executablePath = this.getSyncthingExecutablePath();
        const configDir = `${this.getPluginAbsolutePath()}syncthing-config`;
        if (typeof require !== "undefined") {
          const fs = require("fs");
          if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
          }
        }
        let port = "8384";
        if (this.settings.remoteUrl) {
          const urlMatch = this.settings.remoteUrl.match(/^https?:\/\/(127\.0\.0\.1|localhost):(\d+)/);
          if (urlMatch) {
            port = urlMatch[2];
            console.log(`Using custom port ${port} from remoteUrl: ${this.settings.remoteUrl}`);
          } else {
            console.log(`RemoteUrl set but not localhost, using default port 8384: ${this.settings.remoteUrl}`);
          }
        } else {
          console.log(`No remoteUrl set, using default port 8384`);
        }
        await this.ensureConfigForPort(configDir, port);
        if (this.syncthingInstance) {
          console.log("Stopping existing Syncthing instance before starting with new configuration...");
          await this.stopSyncthing();
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
        const args = [
          "--home",
          configDir,
          "--no-browser",
          "--gui-address",
          `127.0.0.1:${port}`
        ];
        console.log(`Starting Syncthing with args: ${args.join(" ")}`);
        try {
          this.syncthingInstance = spawn(executablePath, args);
        } catch (spawnError) {
          console.error("Failed to spawn Syncthing process:", spawnError);
          new import_obsidian.Notice(`Failed to start Syncthing: ${spawnError.message}. Try re-downloading the executable.`, 1e4);
          return;
        }
        this.syncthingInstance.stdout.on("data", (data) => {
          console.log(`stdout: ${data}`);
        });
        this.syncthingInstance.stderr.on("data", (data) => {
          console.error(`stderr: ${data}`);
        });
        this.syncthingInstance.on("exit", (code) => {
          console.log(`child process exited with code ${code}`);
        });
        this.syncthingInstance.on("error", (error) => {
          console.error("Syncthing process error:", error);
          if (error.code === "ENOEXEC") {
            new import_obsidian.Notice("Syncthing executable cannot be run. This may be due to permission issues or corrupted download. Try re-downloading the executable.", 15e3);
          } else {
            new import_obsidian.Notice(`Syncthing process error: ${error.message}`, 1e4);
          }
        });
        setTimeout(() => {
          this.startStatusMonitoring();
        }, 2e3);
      }
    });
  }
  stopSyncthing() {
    var _a;
    this.monitor.stopMonitoring();
    if (this.isMobile || this.settings.mobileMode) {
      console.log("Mobile mode: No local Syncthing to stop");
      return;
    }
    if (this.settings.useDocker) {
      if (!exec) {
        console.log("Docker operations not available on mobile platforms");
        return;
      }
      const dockerRunCommand = [
        `docker compose`,
        `-f ${this.getPluginAbsolutePath()}docker/docker-compose.yaml`,
        `stop`
      ];
      exec(dockerRunCommand.join(" "), (error, stdout, stderr) => {
        if (error) {
          console.error("Error:", error.message);
          return false;
        }
        if (stderr) {
          console.log(stderr);
          return false;
        }
        console.log("Output:", stdout);
      });
    } else {
      if (!this.syncthingInstance) {
        console.log("No local Syncthing instance to stop");
        return;
      }
      const pid = (_a = this.syncthingInstance) == null ? void 0 : _a.pid;
      if (pid !== void 0) {
        var kill = require_tree_kill();
        kill(pid, "SIGTERM", (err) => {
          if (err) {
            console.error("Failed to kill process tree:", err);
          } else {
            console.log("Process tree killed successfully.");
          }
        });
        this.syncthingInstance = null;
      }
    }
  }
  /**
   * Use Node.js HTTP for config operations to match the monitoring approach
   */
  async pauseSyncthing() {
    try {
      const baseUrl = this.getSyncthingURL();
      const config = await this.getSyncthingConfig();
      for (const folder of config.folders) {
        folder.paused = true;
      }
      return await this.updateSyncthingConfig(config);
    } catch (error) {
      console.error("Failed to pause Syncthing:", error);
      return false;
    }
  }
  async resumeSyncthing() {
    try {
      const baseUrl = this.getSyncthingURL();
      const config = await this.getSyncthingConfig();
      for (const folder of config.folders) {
        folder.paused = false;
      }
      return await this.updateSyncthingConfig(config);
    } catch (error) {
      console.error("Failed to resume Syncthing:", error);
      return false;
    }
  }
  /**
   * Get Syncthing config using Node.js HTTP
   */
  async getSyncthingConfig() {
    return new Promise((resolve, reject) => {
      if (!this.settings.syncthingApiKey) {
        reject(new Error("API key not set"));
        return;
      }
      const url = new URL(this.getSyncthingURL());
      let hostname = url.hostname;
      if (hostname === "localhost") {
        hostname = "127.0.0.1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: "/rest/config",
        method: "GET",
        headers: {
          "X-API-Key": this.settings.syncthingApiKey
        }
      };
      const req = http.request(options, (res) => {
        let body = "";
        res.on("data", (chunk) => body += chunk);
        res.on("end", () => {
          try {
            resolve(JSON.parse(body));
          } catch (error) {
            reject(error);
          }
        });
      });
      req.on("error", reject);
      req.end();
    });
  }
  /**
   * Update Syncthing config using Node.js HTTP
   */
  async updateSyncthingConfig(config) {
    return new Promise((resolve) => {
      if (!this.settings.syncthingApiKey) {
        resolve(false);
        return;
      }
      const url = new URL(this.getSyncthingURL());
      const postData = JSON.stringify(config);
      let hostname = url.hostname;
      if (hostname === "localhost") {
        hostname = "127.0.0.1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: "/rest/config",
        method: "POST",
        headers: {
          "X-API-Key": this.settings.syncthingApiKey,
          "Content-Type": "application/json",
          "Content-Length": Buffer.byteLength(postData)
        }
      };
      const req = http.request(options, (res) => {
        resolve(res.statusCode === 200);
      });
      req.on("error", () => resolve(false));
      req.write(postData);
      req.end();
    });
  }
  async startSyncthingDockerStack() {
    if (!exec) {
      new import_obsidian.Notice("Docker operations not available on mobile platforms", 5e3);
      return;
    }
    this.updateEnvFile({
      VAULT_PATH: `${this.vaultPath}`,
      SYNCTHING_CONFIG_PATH: `${this.vaultPath}/.obsidian/syncthing_config`
    });
    const dockerRunCommand = [
      `docker compose`,
      `-f ${this.getPluginAbsolutePath()}docker/docker-compose.yaml`,
      `up`,
      `-d`
    ];
    exec(dockerRunCommand.join(" "), (error, stdout, stderr) => {
      if (error) {
        console.error("Error:", error.message);
        return false;
      }
      if (stderr) {
        console.log(stderr);
        return false;
      }
      console.log("Output:", stdout);
    });
  }
  updateEnvFile(vars) {
    if (!writeFileSync || !readFileSync) {
      console.log("File system operations not available on mobile platform");
      return;
    }
    const filePath = `${this.getPluginAbsolutePath()}docker/.env`;
    let content = readFileSync(filePath, "utf8");
    Object.entries(vars).forEach(([key, value]) => {
      const regex = new RegExp(`^${key}=.*`, "m");
      content = content.replace(regex, `${key}=${value}`);
    });
    writeFileSync(filePath, content, "utf8");
  }
  async ensureConfigForPort(configDir, port) {
    if (typeof require !== "undefined") {
      const fs = require("fs");
      const path = require("path");
      const portFile = path.join(configDir, ".syncthing-port");
      let storedPort = "";
      if (fs.existsSync(portFile)) {
        try {
          storedPort = fs.readFileSync(portFile, "utf8").trim();
        } catch (error) {
          console.log("Could not read stored port file:", error);
        }
      }
      if (storedPort && storedPort !== port) {
        console.log(`Port changed from ${storedPort} to ${port}, clearing Syncthing config...`);
        try {
          const files = fs.readdirSync(configDir);
          for (const file of files) {
            const filePath = path.join(configDir, file);
            const stat = fs.statSync(filePath);
            if (stat.isFile()) {
              fs.unlinkSync(filePath);
              console.log(`Removed config file: ${file}`);
            } else if (stat.isDirectory() && file !== "." && file !== "..") {
              fs.rmSync(filePath, { recursive: true, force: true });
              console.log(`Removed config directory: ${file}`);
            }
          }
        } catch (error) {
          console.log("Error clearing config directory:", error);
        }
      }
      try {
        fs.writeFileSync(portFile, port, "utf8");
        console.log(`Stored current port: ${port}`);
      } catch (error) {
        console.log("Could not store port file:", error);
      }
    }
  }
  getSyncthingURL() {
    if (this.isMobile || this.settings.mobileMode) {
      console.log(`Using mobile/remote URL: ${this.settings.remoteUrl}`);
      return this.settings.remoteUrl;
    }
    if (this.settings.useDocker) {
      console.log(`Using Docker URL: ${SYNCTHING_CORS_PROXY_CONTAINER_URL}`);
      return SYNCTHING_CORS_PROXY_CONTAINER_URL;
    } else {
      if (this.settings.remoteUrl) {
        console.log(`Using configured remoteUrl: ${this.settings.remoteUrl}`);
        return this.settings.remoteUrl;
      }
      console.log(`Using default localhost URL: http://127.0.0.1:8384`);
      return "http://127.0.0.1:8384";
    }
  }
  /**
   * Use the monitor's improved status detection
   */
  async isSyncthingRunning() {
    return await this.monitor.isSyncthingRunning();
  }
  checkDockerStatus() {
    if (!exec) {
      console.log("Docker operations not available on mobile platforms");
      return false;
    }
    exec("docker ps", (error, stdout, stderr) => {
      if (error) {
        console.error("Error:", error.message);
        return false;
      }
      if (stderr) {
        console.error("Error:", stderr);
        return false;
      }
      console.log("Output:", stdout);
    });
    return true;
  }
  updateStatusBar() {
    this.monitor.isSyncthingRunning().then((isRunning) => {
      if (this.statusBarConnectionIconItem) {
        if (!isRunning) {
          this.statusBarConnectionIconItem.setText("\u26AB");
          this.statusBarConnectionIconItem.ariaLabel = "Click to start Syncthing";
        }
        this.statusBarConnectionIconItem.addClasses(["plugin-editor-status", "mouse-pointer"]);
      }
    });
  }
  /**
   * Update last sync date - called periodically
   */
  updateLastSyncDate() {
    this.getLastSyncDate().then((lastSyncDate) => {
      if (lastSyncDate !== null) {
        const optionsDate = { day: "2-digit", month: "2-digit", year: "2-digit" };
        const formattedDate = lastSyncDate.toLocaleDateString("en-GB", optionsDate).split("/").join(".");
        const optionsTime = { hour: "2-digit", minute: "2-digit", hour12: false };
        const formattedTime = lastSyncDate.toLocaleTimeString("en-GB", optionsTime);
        this.syncthingLastSyncDate = `${formattedDate} ${formattedTime}`;
      } else {
        this.syncthingLastSyncDate = "no data";
      }
      if (this.statusBarLastSyncTextItem) {
        this.statusBarLastSyncTextItem.setText(`Last sync: ${this.syncthingLastSyncDate}`);
      }
    });
  }
  async checkExecutableExists() {
    if (!this.app.vault.adapter || this.isMobile || this.settings.mobileMode) {
      return true;
    }
    try {
      const executablePath = this.getSyncthingExecutablePath();
      if (typeof require !== "undefined") {
        try {
          const fs = require("fs");
          if (!fs.existsSync(executablePath)) {
            console.log("Executable file does not exist:", executablePath);
            return false;
          }
          try {
            fs.accessSync(executablePath, fs.constants.F_OK | fs.constants.X_OK);
            console.log("\u2705 Executable exists and is executable:", executablePath);
            return true;
          } catch (permError) {
            console.log("\u274C Executable exists but is not executable:", executablePath, permError.message);
            if (process.platform !== "win32") {
              try {
                fs.chmodSync(executablePath, "755");
                console.log("Fixed executable permissions");
                fs.accessSync(executablePath, fs.constants.F_OK | fs.constants.X_OK);
                console.log("\u2705 Executable permissions fixed");
                return true;
              } catch (fixError) {
                console.log("\u274C Could not fix executable permissions:", fixError.message);
                return false;
              }
            }
            return false;
          }
        } catch (error) {
          console.error("Error checking file with fs:", error);
        }
      }
      return false;
    } catch (error) {
      console.error("Error checking executable:", error);
      return false;
    }
  }
  /**
   * Download Syncthing executable using official GitHub releases API
   */
  async downloadSyncthingExecutable() {
    try {
      new import_obsidian.Notice("Fetching latest Syncthing release information...", 5e3);
      const releaseInfo = await this.getLatestSyncthingRelease();
      if (!releaseInfo) {
        new import_obsidian.Notice("Failed to fetch latest Syncthing release information", 8e3);
        return false;
      }
      let platformPattern;
      let expectedExecutableName;
      console.log(`Detected platform: ${process.platform}, architecture: ${process.arch}`);
      if (process.platform === "win32") {
        const arch = process.arch === "x64" ? "amd64" : process.arch === "arm64" ? "arm64" : "386";
        platformPattern = `syncthing-windows-${arch}-v${releaseInfo.version}`;
        expectedExecutableName = "syncthing.exe";
      } else if (process.platform === "darwin") {
        let arch;
        if (process.arch === "arm64") {
          arch = "arm64";
        } else if (process.arch === "x64") {
          arch = "amd64";
        } else {
          console.log(`Unknown macOS architecture ${process.arch}, trying universal build`);
          arch = "universal";
        }
        platformPattern = `syncthing-macos-${arch}-v${releaseInfo.version}`;
        expectedExecutableName = "syncthing";
        console.log(`Selected macOS pattern: ${platformPattern}`);
      } else {
        const arch = process.arch === "x64" ? "amd64" : process.arch === "arm64" ? "arm64" : process.arch === "arm" ? "arm" : "386";
        platformPattern = `syncthing-linux-${arch}-v${releaseInfo.version}`;
        expectedExecutableName = "syncthing";
      }
      console.log(`Looking for release asset matching: ${platformPattern}`);
      console.log(`Available assets: ${releaseInfo.assets.map((a) => a.name).join(", ")}`);
      const asset = releaseInfo.assets.find(
        (asset2) => asset2.name.startsWith(platformPattern)
      );
      if (!asset) {
        if (process.platform === "darwin") {
          console.log("Primary macOS asset not found, trying fallbacks...");
          const universalPattern = `syncthing-macos-universal-v${releaseInfo.version}`;
          const universalAsset = releaseInfo.assets.find(
            (asset2) => asset2.name.startsWith(universalPattern)
          );
          if (universalAsset) {
            console.log(`Found universal macOS build: ${universalAsset.name}`);
            new import_obsidian.Notice(`Using universal macOS build for ${process.arch} architecture`, 5e3);
            return this.downloadAndInstallAsset(universalAsset, expectedExecutableName);
          }
          if (process.arch === "x64") {
            const amd64Pattern = `syncthing-macos-amd64-v${releaseInfo.version}`;
            const amd64Asset = releaseInfo.assets.find(
              (asset2) => asset2.name.startsWith(amd64Pattern)
            );
            if (amd64Asset) {
              console.log(`Found amd64 macOS build: ${amd64Asset.name}`);
              new import_obsidian.Notice(`Using amd64 macOS build for x64 architecture`, 5e3);
              return this.downloadAndInstallAsset(amd64Asset, expectedExecutableName);
            }
          }
        }
        new import_obsidian.Notice(`No Syncthing release found for ${process.platform} ${process.arch}. Available assets: ${releaseInfo.assets.map((a) => a.name).join(", ")}`, 1e4);
        return false;
      }
      return this.downloadAndInstallAsset(asset, expectedExecutableName);
    } catch (error) {
      console.error("Failed to download Syncthing executable:", error);
      new import_obsidian.Notice(`Failed to download Syncthing executable: ${error.message}. Please download manually from GitHub release.`, 1e4);
      return false;
    }
  }
  /**
   * Download and install a specific asset
   */
  async downloadAndInstallAsset(asset, expectedExecutableName) {
    var _a, _b;
    try {
      new import_obsidian.Notice(`Downloading Syncthing ${((_a = asset.name.match(/v(\d+\.\d+\.\d+)/)) == null ? void 0 : _a[1]) || "latest"} for ${process.platform} ${process.arch}... Please wait.`, 8e3);
      console.log(`Downloading Syncthing from: ${asset.browser_download_url}`);
      const archiveData = await this.downloadFile(asset.browser_download_url);
      if (!archiveData) {
        new import_obsidian.Notice("Failed to download Syncthing archive", 8e3);
        return false;
      }
      const success = await this.extractAndInstallSyncthing(archiveData, asset.name, expectedExecutableName);
      if (success) {
        const version = ((_b = asset.name.match(/v(\d+\.\d+\.\d+)/)) == null ? void 0 : _b[1]) || "latest";
        new import_obsidian.Notice(`Syncthing ${version} downloaded and installed successfully!`, 5e3);
        return true;
      } else {
        new import_obsidian.Notice("Failed to extract and install Syncthing executable", 8e3);
        return false;
      }
    } catch (error) {
      console.error("Failed to download and install asset:", error);
      new import_obsidian.Notice(`Failed to download and install: ${error.message}`, 8e3);
      return false;
    }
  }
  /**
   * Get latest release information from Syncthing GitHub API
   */
  async getLatestSyncthingRelease() {
    return new Promise((resolve, reject) => {
      const https = require("https");
      const options = {
        hostname: "api.github.com",
        port: 443,
        path: "/repos/syncthing/syncthing/releases/latest",
        method: "GET",
        headers: {
          "User-Agent": "Obsidian-Syncthing-Launcher-Plugin"
        }
      };
      const req = https.request(options, (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          try {
            const releaseData = JSON.parse(data);
            if (res.statusCode !== 200) {
              reject(new Error(`GitHub API error: ${res.statusCode} - ${releaseData.message || "Unknown error"}`));
              return;
            }
            resolve({
              version: releaseData.tag_name.replace("v", ""),
              // Remove 'v' prefix
              assets: releaseData.assets,
              html_url: releaseData.html_url
            });
          } catch (error) {
            reject(new Error(`Failed to parse GitHub API response: ${error.message}`));
          }
        });
      });
      req.on("error", (error) => {
        reject(new Error(`Failed to fetch release info: ${error.message}`));
      });
      req.setTimeout(1e4, () => {
        req.destroy();
        reject(new Error("GitHub API request timeout"));
      });
      req.end();
    });
  }
  /**
   * Download a file using Node.js HTTPS
   */
  async downloadFile(url) {
    return new Promise((resolve) => {
      const https = require("https");
      const urlModule = require("url");
      const parsedUrl = urlModule.parse(url);
      const options = {
        hostname: parsedUrl.hostname,
        port: 443,
        path: parsedUrl.path,
        method: "GET",
        headers: {
          "User-Agent": "Obsidian-Syncthing-Launcher-Plugin"
        }
      };
      const req = https.request(options, (res) => {
        if (res.statusCode === 302 || res.statusCode === 301) {
          this.downloadFile(res.headers.location).then(resolve);
          return;
        }
        if (res.statusCode !== 200) {
          console.error(`Download failed with status ${res.statusCode}`);
          resolve(null);
          return;
        }
        const chunks = [];
        res.on("data", (chunk) => chunks.push(chunk));
        res.on("end", () => {
          resolve(Buffer.concat(chunks));
        });
      });
      req.on("error", (error) => {
        console.error("Download failed:", error);
        resolve(null);
      });
      req.setTimeout(6e4, () => {
        req.destroy();
        console.error("Download timeout");
        resolve(null);
      });
      req.end();
    });
  }
  /**
   * Extract and install Syncthing executable from downloaded archive
   */
  async extractAndInstallSyncthing(archiveData, archiveName, executableName) {
    if (typeof require === "undefined") {
      console.error("File system operations not available");
      return false;
    }
    try {
      const fs = require("fs");
      const path = require("path");
      const syncthingDir = path.join(this.getPluginAbsolutePath(), "syncthing");
      if (!fs.existsSync(syncthingDir)) {
        fs.mkdirSync(syncthingDir, { recursive: true });
      }
      const isZip = archiveName.endsWith(".zip");
      const isTarGz = archiveName.endsWith(".tar.gz");
      if (isZip) {
        const yauzl = await this.extractZip(archiveData, syncthingDir, executableName);
        return yauzl;
      } else if (isTarGz) {
        return await this.extractTarGz(archiveData, syncthingDir, executableName);
      } else {
        console.error("Unsupported archive format:", archiveName);
        return false;
      }
    } catch (error) {
      console.error("Failed to extract archive:", error);
      return false;
    }
  }
  /**
   * Extract ZIP archive (for Windows and macOS)
   */
  async extractZip(zipData, targetDir, executableName) {
    try {
      const fs = require("fs");
      const path = require("path");
      const { spawn: spawn2 } = require("child_process");
      const tempZipPath = path.join(targetDir, "temp-syncthing.zip");
      fs.writeFileSync(tempZipPath, zipData);
      console.log(`Saved ZIP archive to: ${tempZipPath} (${zipData.length} bytes)`);
      return new Promise((resolve) => {
        var _a, _b;
        let extractCommand;
        let extractArgs;
        if (process.platform === "win32") {
          extractCommand = "powershell";
          extractArgs = ["-Command", `Expand-Archive -Path "${tempZipPath}" -DestinationPath "${targetDir}" -Force`];
        } else {
          extractCommand = "unzip";
          extractArgs = ["-o", tempZipPath, "-d", targetDir];
        }
        console.log(`Extracting with command: ${extractCommand} ${extractArgs.join(" ")}`);
        const extractProcess = spawn2(extractCommand, extractArgs);
        let stdout = "";
        let stderr = "";
        (_a = extractProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
          stdout += data.toString();
        });
        (_b = extractProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
          stderr += data.toString();
        });
        extractProcess.on("close", (code) => {
          console.log(`Extraction completed with code: ${code}`);
          if (stdout)
            console.log(`Extraction stdout: ${stdout}`);
          if (stderr)
            console.log(`Extraction stderr: ${stderr}`);
          try {
            if (fs.existsSync(tempZipPath)) {
              fs.unlinkSync(tempZipPath);
              console.log("Cleaned up temporary ZIP file");
            }
            if (code === 0) {
              try {
                const contents = fs.readdirSync(targetDir);
                console.log(`Contents of ${targetDir}: ${contents.join(", ")}`);
              } catch (listError) {
                console.log("Could not list directory contents:", listError);
              }
              this.findAndCopyExecutable(targetDir, executableName).then(resolve);
            } else {
              console.error("Extraction failed with code:", code);
              resolve(false);
            }
          } catch (error) {
            console.error("Post-extraction error:", error);
            resolve(false);
          }
        });
        extractProcess.on("error", (error) => {
          console.error("Extraction command failed:", error);
          try {
            if (fs.existsSync(tempZipPath)) {
              fs.unlinkSync(tempZipPath);
            }
          } catch (e) {
          }
          resolve(false);
        });
      });
    } catch (error) {
      console.error("ZIP extraction error:", error);
      return false;
    }
  }
  /**
   * Extract TAR.GZ archive (for Linux)
   */
  async extractTarGz(tarData, targetDir, executableName) {
    try {
      const fs = require("fs");
      const path = require("path");
      const { spawn: spawn2 } = require("child_process");
      const tempTarPath = path.join(targetDir, "temp-syncthing.tar.gz");
      fs.writeFileSync(tempTarPath, tarData);
      return new Promise((resolve) => {
        const extractProcess = spawn2("tar", ["-xzf", tempTarPath, "-C", targetDir]);
        extractProcess.on("close", (code) => {
          try {
            if (fs.existsSync(tempTarPath)) {
              fs.unlinkSync(tempTarPath);
            }
            if (code === 0) {
              this.findAndCopyExecutable(targetDir, executableName).then(resolve);
            } else {
              console.error("TAR extraction failed with code:", code);
              resolve(false);
            }
          } catch (error) {
            console.error("Post-extraction error:", error);
            resolve(false);
          }
        });
        extractProcess.on("error", (error) => {
          console.error("TAR extraction command failed:", error);
          try {
            if (fs.existsSync(tempTarPath)) {
              fs.unlinkSync(tempTarPath);
            }
          } catch (e) {
          }
          resolve(false);
        });
      });
    } catch (error) {
      console.error("TAR.GZ extraction error:", error);
      return false;
    }
  }
  /**
   * Find and copy the Syncthing executable to the final location
   */
  async findAndCopyExecutable(extractDir, executableName) {
    try {
      const fs = require("fs");
      const path = require("path");
      const { exec: exec2 } = require("child_process");
      console.log(`Looking for executable "${executableName}" in: ${extractDir}`);
      const findExecutable = (dir) => {
        const items = fs.readdirSync(dir);
        console.log(`Searching in ${dir}: found items: ${items.join(", ")}`);
        for (const item of items) {
          const itemPath = path.join(dir, item);
          const stat = fs.statSync(itemPath);
          if (stat.isFile() && item === executableName) {
            try {
              const sizeInMB = (stat.size / 1024 / 1024).toFixed(1);
              console.log(`Found potential executable: ${itemPath} (${stat.size} bytes = ${sizeInMB} MB)`);
              if (stat.size > 1024 * 1024) {
                console.log(`\u2705 Found legitimate executable: ${itemPath}`);
                return itemPath;
              } else {
                console.log(`\u26A0\uFE0F Skipping small file (likely config): ${itemPath} (${stat.size} bytes)`);
              }
            } catch (statError) {
              console.log(`Could not stat file: ${itemPath}`, statError);
            }
          }
        }
        for (const item of items) {
          const itemPath = path.join(dir, item);
          const stat = fs.statSync(itemPath);
          if (stat.isDirectory()) {
            const found = findExecutable(itemPath);
            if (found)
              return found;
          }
        }
        return null;
      };
      const executablePath = findExecutable(extractDir);
      if (!executablePath) {
        console.error(`\u274C Executable ${executableName} not found in extracted archive`);
        return false;
      }
      const execStats = fs.statSync(executablePath);
      const execSizeInMB = (execStats.size / 1024 / 1024).toFixed(1);
      console.log(`Selected executable: ${executablePath} (${execStats.size} bytes = ${execSizeInMB} MB)`);
      if (execStats.size < 1024 * 1024) {
        console.error(`\u274C Selected file is too small to be a Syncthing binary (${execStats.size} bytes). This is likely a config file, not the executable.`);
        return false;
      }
      if (process.platform === "darwin") {
        try {
          const fileTypeCheck = await new Promise((resolve) => {
            exec2(`file "${executablePath}"`, (error, stdout) => {
              resolve(stdout || "Could not determine file type");
            });
          });
          console.log(`Pre-copy file type check: ${fileTypeCheck.trim()}`);
          if (fileTypeCheck.includes("ASCII text") || fileTypeCheck.includes("text")) {
            console.error(`\u274C Selected file is a text file, not a binary: ${fileTypeCheck.trim()}`);
            return false;
          }
        } catch (typeError) {
          console.log("Could not verify file type (non-fatal):", typeError);
        }
      }
      let finalPath;
      if (process.platform === "win32") {
        finalPath = path.join(extractDir, "syncthing.exe");
      } else if (process.platform === "darwin") {
        finalPath = path.join(extractDir, "syncthing-macos");
      } else {
        finalPath = path.join(extractDir, "syncthing-linux");
      }
      console.log(`Copying executable from ${executablePath} to ${finalPath}`);
      fs.copyFileSync(executablePath, finalPath);
      console.log(`\u2705 Executable copied successfully`);
      if (process.platform !== "win32") {
        fs.chmodSync(finalPath, "755");
        console.log("\u2705 Set executable permissions (755)");
        if (process.platform === "darwin") {
          try {
            await new Promise((resolve, reject) => {
              exec2(`xattr -d com.apple.quarantine "${finalPath}"`, (error) => {
                if (error && !error.message.includes("No such xattr")) {
                  console.log("Note: Could not remove quarantine attribute:", error.message);
                } else {
                  console.log("\u2705 Removed macOS quarantine attribute from executable");
                }
                resolve();
              });
            });
          } catch (error) {
            console.log("Note: Could not remove quarantine attribute (non-fatal):", error);
          }
          try {
            const fileTypeOutput = await new Promise((resolve) => {
              exec2(`file "${finalPath}"`, (error, stdout) => {
                resolve(stdout || "Could not determine file type");
              });
            });
            console.log(`File type check: ${fileTypeOutput.trim()}`);
            const archOutput = await new Promise((resolve) => {
              exec2(`lipo -info "${finalPath}" 2>/dev/null || otool -hv "${finalPath}" 2>/dev/null || echo "Not a Mach-O binary"`, (error, stdout) => {
                resolve(stdout || "Could not determine architecture");
              });
            });
            console.log(`Architecture check: ${archOutput.trim()}`);
          } catch (debugError) {
            console.log("Debug checks failed (non-fatal):", debugError);
          }
        }
      }
      this.cleanupExtractedFiles(extractDir, path.basename(finalPath));
      console.log(`Syncthing executable installed to: ${finalPath}`);
      try {
        const stats = fs.statSync(finalPath);
        const mode = stats.mode;
        console.log(`Executable permissions: ${(mode & parseInt("777", 8)).toString(8)}`);
        console.log(`File size: ${stats.size} bytes`);
        fs.accessSync(finalPath, fs.constants.F_OK | fs.constants.X_OK);
        console.log("\u2705 Executable permissions verified");
        if (process.platform === "darwin") {
          try {
            const testOutput = await new Promise((resolve, reject) => {
              exec2(`"${finalPath}" --version`, { timeout: 5e3 }, (error, stdout, stderr) => {
                if (error) {
                  reject(error);
                } else {
                  resolve(stdout.trim());
                }
              });
            });
            console.log("\u2705 Executable test run successful:", testOutput.split("\n")[0]);
          } catch (testError) {
            console.log("\u274C Executable test run failed:", testError.message);
            console.log("This indicates the binary may not be compatible or corrupted");
            return false;
          }
        }
      } catch (permError) {
        console.error("\u274C Executable permissions issue:", permError);
        throw new Error(`Executable not accessible: ${permError.message}`);
      }
      return true;
    } catch (error) {
      console.error("Failed to find and copy executable:", error);
      return false;
    }
  }
  /**
   * Clean up extracted files, keeping only the renamed executable
   */
  cleanupExtractedFiles(dir, keepFile) {
    try {
      const fs = require("fs");
      const path = require("path");
      const items = fs.readdirSync(dir);
      for (const item of items) {
        if (item === keepFile)
          continue;
        const itemPath = path.join(dir, item);
        const stat = fs.statSync(itemPath);
        if (stat.isDirectory()) {
          fs.rmSync(itemPath, { recursive: true, force: true });
        } else {
          fs.unlinkSync(itemPath);
        }
      }
    } catch (error) {
      console.error("Cleanup error (non-fatal):", error);
    }
  }
  detectMobilePlatform() {
    const platform = process.platform;
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
    const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    return isMobileUA || isTouchDevice && window.innerWidth < 1024;
  }
  getPluginAbsolutePath() {
    let basePath;
    if (this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = this.app.vault.adapter.getBasePath();
    } else {
      throw new Error("Cannot determine base path.");
    }
    const relativePath = `${this.app.vault.configDir}/plugins/${this.manifest.id}-${this.manifest.version}/`;
    return `${basePath}/${relativePath}`;
  }
  getSyncthingExecutablePath() {
    const pluginPath = this.getPluginAbsolutePath();
    if (process.platform === "win32") {
      return `${pluginPath}syncthing/syncthing.exe`;
    } else if (process.platform === "darwin") {
      return `${pluginPath}syncthing/syncthing-macos`;
    } else {
      return `${pluginPath}syncthing/syncthing-linux`;
    }
  }
  /**
   * Get the last sync date using Node.js HTTP
   */
  async getLastSyncDate() {
    return new Promise((resolve) => {
      if (!this.settings.syncthingApiKey || !this.settings.vaultFolderID) {
        resolve(null);
        return;
      }
      const url = new URL(this.getSyncthingURL());
      let hostname = url.hostname;
      if (hostname === "localhost" || hostname === "127.0.0.1") {
        hostname = "::1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: `/rest/db/status?folder=${this.settings.vaultFolderID}`,
        method: "GET",
        headers: {
          "X-API-Key": this.settings.syncthingApiKey
        }
      };
      const req = http.request(options, (res) => {
        let body = "";
        res.on("data", (chunk) => body += chunk);
        res.on("end", () => {
          try {
            const data = JSON.parse(body);
            if (data.stateChanged) {
              resolve(new Date(data.stateChanged));
            } else {
              resolve(null);
            }
          } catch (error) {
            console.error("Failed to parse sync date response:", error);
            resolve(null);
          }
        });
      });
      req.on("error", (error) => {
        console.error("Failed to get last sync date:", error);
        resolve(null);
      });
      req.end();
    });
  }
  // --- Settings ---
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.monitor.stopMonitoring();
    setTimeout(() => {
      this.startStatusMonitoring();
    }, 1e3);
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.activeTab = "overview";
    this.refreshInterval = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createDiv("syncthing-settings", (settingsEl) => {
      const tabsEl = settingsEl.createDiv("syncthing-tabs");
      const tabs = [
        { id: "overview", label: "Overview", icon: "\u{1F4CA}" },
        { id: "configuration", label: "Configuration", icon: "\u2699\uFE0F" },
        { id: "advanced", label: "Advanced", icon: "\u{1F527}" },
        { id: "about", label: "About", icon: "\u2139\uFE0F" }
      ];
      tabs.forEach((tab) => {
        const tabEl = tabsEl.createEl("button", {
          cls: `syncthing-tab ${this.activeTab === tab.id ? "active" : ""}`,
          text: `${tab.icon} ${tab.label}`
        });
        tabEl.addEventListener("click", () => {
          this.activeTab = tab.id;
          this.display();
        });
      });
      this.renderTabContent(settingsEl);
    });
    if (this.activeTab === "overview") {
      this.startAutoRefresh();
    }
  }
  renderTabContent(container) {
    const contentEl = container.createDiv("syncthing-tab-content active");
    switch (this.activeTab) {
      case "overview":
        this.renderOverviewTab(contentEl);
        break;
      case "configuration":
        this.renderConfigurationTab(contentEl);
        break;
      case "advanced":
        this.renderAdvancedTab(contentEl);
        break;
      case "about":
        this.renderAboutTab(contentEl);
        break;
    }
  }
  renderOverviewTab(container) {
    const statusCard = container.createDiv("syncthing-status-card");
    const statusHeader = statusCard.createDiv("syncthing-status-header");
    statusHeader.createEl("h2", { cls: "syncthing-status-title", text: "Syncthing Status" });
    const statusIndicator = statusHeader.createSpan("syncthing-status-indicator unknown");
    statusIndicator.textContent = "Checking...";
    const statusInfo = statusCard.createDiv("syncthing-status-info");
    const executableItem = statusInfo.createDiv("syncthing-info-item");
    executableItem.createDiv({ cls: "syncthing-info-label", text: "Executable" });
    const executableValue = executableItem.createDiv("syncthing-info-value");
    this.plugin.checkExecutableExists().then((exists) => {
      executableValue.textContent = exists ? "Found" : "Not found";
    });
    const configItem = statusInfo.createDiv("syncthing-info-item");
    configItem.createDiv({ cls: "syncthing-info-label", text: "Config" });
    const configValue = configItem.createDiv("syncthing-info-value");
    configValue.textContent = this.plugin.settings.syncthingApiKey ? "Configured" : "Not configured";
    const modeItem = statusInfo.createDiv("syncthing-info-item");
    modeItem.createDiv({ cls: "syncthing-info-label", text: "Mode" });
    const modeValue = modeItem.createDiv("syncthing-info-value");
    modeValue.textContent = this.plugin.settings.mobileMode ? "Mobile" : "Desktop";
    const urlItem = statusInfo.createDiv("syncthing-info-item");
    urlItem.createDiv({ cls: "syncthing-info-label", text: "URL" });
    const urlValue = urlItem.createDiv("syncthing-info-value");
    urlValue.textContent = this.plugin.getSyncthingURL();
    const controls = statusCard.createDiv("syncthing-controls");
    const startBtn = controls.createEl("button", {
      cls: "syncthing-btn success",
      text: "\u{1F680} Start"
    });
    startBtn.addEventListener("click", async () => {
      try {
        await this.plugin.startSyncthing();
        new import_obsidian.Notice("Syncthing started successfully");
        this.updateStatus();
      } catch (error) {
        new import_obsidian.Notice(`Failed to start Syncthing: ${error.message}`);
      }
    });
    const stopBtn = controls.createEl("button", {
      cls: "syncthing-btn danger",
      text: "\u23F9\uFE0F Stop"
    });
    stopBtn.addEventListener("click", async () => {
      try {
        await this.plugin.stopSyncthing();
        new import_obsidian.Notice("Syncthing stopped");
        this.updateStatus();
      } catch (error) {
        new import_obsidian.Notice(`Failed to stop Syncthing: ${error.message}`);
      }
    });
    const restartBtn = controls.createEl("button", {
      cls: "syncthing-btn secondary",
      text: "\u{1F504} Restart"
    });
    restartBtn.addEventListener("click", async () => {
      try {
        await this.plugin.stopSyncthing();
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        await this.plugin.startSyncthing();
        new import_obsidian.Notice("Syncthing restarted");
        this.updateStatus();
      } catch (error) {
        new import_obsidian.Notice(`Failed to restart Syncthing: ${error.message}`);
      }
    });
    const openBtn = controls.createEl("button", {
      cls: "syncthing-btn primary",
      text: "\u{1F310} Open GUI"
    });
    openBtn.addEventListener("click", () => {
      const url = this.plugin.getSyncthingURL();
      window.open(url, "_blank");
    });
    const updateStatusFromMonitor = (data) => {
      let statusText = "\u2753 Unknown";
      let statusClass = "unknown";
      if (data.status === "Invalid API key") {
        statusText = "Invalid API key";
        statusClass = "stopped";
      } else if (data.status === "API key not set") {
        statusText = "API key not set";
        statusClass = "stopped";
      } else if (data.connectedDevicesCount === 0) {
        statusText = "No devices connected";
        statusClass = "stopped";
      } else if (data.status === "scanning") {
        statusText = "Scanning";
        statusClass = "running";
      } else if (data.fileCompletion !== void 0 && data.fileCompletion < 100) {
        statusText = `Syncing (${data.fileCompletion.toFixed(1)}%)`;
        statusClass = "running";
      } else {
        statusText = "Connected";
        statusClass = "running";
      }
      statusIndicator.className = `syncthing-status-indicator ${statusClass}`;
      statusIndicator.textContent = statusText;
    };
    this.plugin.monitor.on("status-update", updateStatusFromMonitor);
    this.updateStatus();
  }
  renderConfigurationTab(container) {
    const apiSection = container.createDiv("syncthing-section");
    apiSection.createEl("h3", { cls: "syncthing-section-title", text: "\u{1F517} API Configuration" });
    apiSection.createDiv({
      cls: "syncthing-section-description",
      text: "Configure connection to Syncthing API. Find these settings in Syncthing GUI \u2192 Actions \u2192 Settings."
    });
    const apiKeyGroup = apiSection.createDiv("syncthing-form-group");
    apiKeyGroup.createEl("label", { cls: "syncthing-label", text: "API Key" });
    const apiKeyInput = apiKeyGroup.createEl("input", {
      cls: "syncthing-input",
      attr: { type: "password", value: this.plugin.settings.syncthingApiKey, placeholder: "Enter Syncthing API key" }
    });
    apiKeyGroup.createDiv({
      cls: "syncthing-help-text",
      text: "API key for authentication (found in Syncthing GUI \u2192 Settings \u2192 GUI)"
    });
    const folderIdGroup = apiSection.createDiv("syncthing-form-group");
    folderIdGroup.createEl("label", { cls: "syncthing-label", text: "Vault Folder ID" });
    const folderIdInput = folderIdGroup.createEl("input", {
      cls: "syncthing-input",
      attr: { type: "text", value: this.plugin.settings.vaultFolderID, placeholder: "Enter vault folder ID" }
    });
    folderIdGroup.createDiv({
      cls: "syncthing-help-text",
      text: "ID of the folder containing your vault (found in Syncthing GUI \u2192 Folders)"
    });
    const modeSection = container.createDiv("syncthing-section");
    modeSection.createEl("h3", { cls: "syncthing-section-title", text: "\u{1F4F1} Connection Mode" });
    modeSection.createDiv({
      cls: "syncthing-section-description",
      text: "Choose how to connect to Syncthing: run locally, connect to remote instance, or use Docker."
    });
    const mobileGroup = modeSection.createDiv("syncthing-form-group");
    const mobileCheckbox = mobileGroup.createEl("label", { cls: "syncthing-checkbox" });
    const mobileInput = mobileCheckbox.createEl("input", { attr: { type: "checkbox" } });
    mobileInput.checked = this.plugin.settings.mobileMode;
    mobileCheckbox.createSpan({ text: "Mobile Mode (connect to remote Syncthing)" });
    const dockerGroup = modeSection.createDiv("syncthing-form-group");
    const dockerCheckbox = dockerGroup.createEl("label", { cls: "syncthing-checkbox" });
    const dockerInput = dockerCheckbox.createEl("input", { attr: { type: "checkbox" } });
    dockerInput.checked = this.plugin.settings.useDocker;
    dockerCheckbox.createSpan({ text: "Use Docker (run Syncthing in container)" });
    const remoteUrlGroup = modeSection.createDiv("syncthing-form-group");
    remoteUrlGroup.createEl("label", { cls: "syncthing-label", text: "Remote Syncthing URL" });
    const remoteUrlInput = remoteUrlGroup.createEl("input", {
      cls: "syncthing-input",
      attr: { type: "text", value: this.plugin.settings.remoteUrl, placeholder: "http://192.168.1.100:8384" }
    });
    remoteUrlGroup.createDiv({
      cls: "syncthing-help-text",
      text: "URL of remote Syncthing instance (used in mobile mode)"
    });
    const startupSection = container.createDiv("syncthing-section");
    startupSection.createEl("h3", { cls: "syncthing-section-title", text: "\u{1F680} Startup Configuration" });
    startupSection.createDiv({
      cls: "syncthing-section-description",
      text: "Control when Syncthing starts and stops with Obsidian."
    });
    const autoStartGroup = startupSection.createDiv("syncthing-form-group");
    const autoStartCheckbox = autoStartGroup.createEl("label", { cls: "syncthing-checkbox" });
    const autoStartInput = autoStartCheckbox.createEl("input", { attr: { type: "checkbox" } });
    autoStartInput.checked = this.plugin.settings.startOnObsidianOpen;
    autoStartCheckbox.createSpan({ text: "Start Syncthing when Obsidian opens" });
    const autoStopGroup = startupSection.createDiv("syncthing-form-group");
    const autoStopCheckbox = autoStopGroup.createEl("label", { cls: "syncthing-checkbox" });
    const autoStopInput = autoStopCheckbox.createEl("input", { attr: { type: "checkbox" } });
    autoStopInput.checked = this.plugin.settings.stopOnObsidianClose;
    autoStopCheckbox.createSpan({ text: "Stop Syncthing when Obsidian closes" });
    const saveBtn = container.createEl("button", {
      cls: "syncthing-btn primary",
      text: "\u{1F4BE} Save Configuration"
    });
    saveBtn.addEventListener("click", async () => {
      this.plugin.settings.syncthingApiKey = apiKeyInput.value;
      this.plugin.settings.vaultFolderID = folderIdInput.value;
      this.plugin.settings.mobileMode = mobileInput.checked;
      this.plugin.settings.useDocker = dockerInput.checked;
      this.plugin.settings.remoteUrl = remoteUrlInput.value;
      this.plugin.settings.startOnObsidianOpen = autoStartInput.checked;
      this.plugin.settings.stopOnObsidianClose = autoStopInput.checked;
      await this.plugin.saveSettings();
      new import_obsidian.Notice("Settings saved successfully");
    });
  }
  renderAdvancedTab(container) {
    const binarySection = container.createDiv("syncthing-section");
    binarySection.createEl("h3", { cls: "syncthing-section-title", text: "\u{1F4E6} Binary Management" });
    binarySection.createDiv({
      cls: "syncthing-section-description",
      text: "Download, verify, and manage the Syncthing executable."
    });
    const binaryDiagnostic = binarySection.createDiv("syncthing-diagnostic");
    binaryDiagnostic.createDiv({ cls: "syncthing-diagnostic-title", text: "Executable Status" });
    const pathItem = binaryDiagnostic.createDiv("syncthing-diagnostic-item");
    pathItem.createSpan({ cls: "syncthing-diagnostic-label", text: "Path:" });
    pathItem.createSpan({
      cls: "syncthing-diagnostic-value",
      text: this.plugin.getSyncthingExecutablePath()
    });
    const statusItem = binaryDiagnostic.createDiv("syncthing-diagnostic-item");
    statusItem.createSpan({ cls: "syncthing-diagnostic-label", text: "Status:" });
    const statusValue = statusItem.createSpan({ cls: "syncthing-diagnostic-value" });
    this.plugin.checkExecutableExists().then((exists) => {
      statusValue.textContent = exists ? "Found" : "Not found";
    });
    const binaryControls = binarySection.createDiv("syncthing-controls");
    const downloadBtn = binaryControls.createEl("button", {
      cls: "syncthing-btn primary",
      text: "\u2B07\uFE0F Download"
    });
    downloadBtn.addEventListener("click", async () => {
      downloadBtn.disabled = true;
      downloadBtn.textContent = "\u23F3 Downloading...";
      try {
        const success = await this.plugin.downloadSyncthingExecutable();
        if (success) {
          new import_obsidian.Notice("\u2705 Syncthing downloaded successfully");
          this.renderAdvancedTab(container);
        } else {
          new import_obsidian.Notice("\u274C Download failed");
        }
      } catch (error) {
        new import_obsidian.Notice(`Download failed: ${error.message}`);
      } finally {
        downloadBtn.disabled = false;
        downloadBtn.textContent = "\u2B07\uFE0F Download";
      }
    });
    const redownloadBtn = binaryControls.createEl("button", {
      cls: "syncthing-btn secondary",
      text: "\u{1F504} Re-download"
    });
    redownloadBtn.addEventListener("click", async () => {
      redownloadBtn.disabled = true;
      redownloadBtn.textContent = "\u23F3 Re-downloading...";
      try {
        const executablePath = this.plugin.getSyncthingExecutablePath();
        if (typeof require !== "undefined") {
          const fs = require("fs");
          const path = require("path");
          try {
            const syncthingDir = path.dirname(executablePath);
            if (fs.existsSync(syncthingDir)) {
              fs.rmSync(syncthingDir, { recursive: true, force: true });
            }
          } catch (removeError) {
            console.log("Could not remove existing executable:", removeError);
          }
        }
        const success = await this.plugin.downloadSyncthingExecutable();
        if (success) {
          new import_obsidian.Notice("\u2705 Syncthing re-downloaded successfully");
          this.renderAdvancedTab(container);
        } else {
          new import_obsidian.Notice("\u274C Re-download failed");
        }
      } catch (error) {
        new import_obsidian.Notice(`Re-download failed: ${error.message}`);
      } finally {
        redownloadBtn.disabled = false;
        redownloadBtn.textContent = "\u{1F504} Re-download";
      }
    });
    const checkBtn = binaryControls.createEl("button", {
      cls: "syncthing-btn secondary",
      text: "\u2705 Check"
    });
    checkBtn.addEventListener("click", async () => {
      const exists = await this.plugin.checkExecutableExists();
      if (exists) {
        new import_obsidian.Notice("\u2705 Syncthing executable found and accessible");
      } else {
        new import_obsidian.Notice("\u274C Syncthing executable not found");
      }
    });
    const controlSection = container.createDiv("syncthing-section");
    controlSection.createEl("h3", { cls: "syncthing-section-title", text: "\u{1F39B}\uFE0F Control Actions" });
    const controlActions = controlSection.createDiv("syncthing-controls");
    const pauseBtn = controlActions.createEl("button", {
      cls: "syncthing-btn secondary",
      text: "\u23F8\uFE0F Pause Sync"
    });
    pauseBtn.addEventListener("click", async () => {
      try {
        const success = await this.plugin.pauseSyncthing();
        if (success) {
          new import_obsidian.Notice("Syncthing paused successfully");
        } else {
          new import_obsidian.Notice("Failed to pause Syncthing");
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to pause Syncthing: ${error.message}`);
      }
    });
    const resumeBtn = controlActions.createEl("button", {
      cls: "syncthing-btn success",
      text: "\u25B6\uFE0F Resume Sync"
    });
    resumeBtn.addEventListener("click", async () => {
      try {
        const success = await this.plugin.resumeSyncthing();
        if (success) {
          new import_obsidian.Notice("Syncthing resumed successfully");
        } else {
          new import_obsidian.Notice("Failed to resume Syncthing");
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to resume Syncthing: ${error.message}`);
      }
    });
    const resetBtn = controlActions.createEl("button", {
      cls: "syncthing-btn danger",
      text: "\u{1F504} Reset Config"
    });
    resetBtn.addEventListener("click", async () => {
      try {
        await this.plugin.stopSyncthing();
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        if (typeof require !== "undefined") {
          const fs = require("fs");
          const path = require("path");
          const configDir = `${this.plugin.getPluginAbsolutePath()}syncthing-config`;
          if (fs.existsSync(configDir)) {
            fs.rmSync(configDir, { recursive: true, force: true });
            new import_obsidian.Notice("Syncthing configuration reset successfully");
          } else {
            new import_obsidian.Notice("No configuration found to reset");
          }
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to reset configuration: ${error.message}`);
      }
    });
    const diagnosticsSection = container.createDiv("syncthing-section");
    diagnosticsSection.createEl("h3", { cls: "syncthing-section-title", text: "\u{1F50D} System Diagnostics" });
    const diagnostics = diagnosticsSection.createDiv("syncthing-diagnostic");
    diagnostics.createDiv({ cls: "syncthing-diagnostic-title", text: "System Information" });
    const platformItem = diagnostics.createDiv("syncthing-diagnostic-item");
    platformItem.createSpan({ cls: "syncthing-diagnostic-label", text: "Platform:" });
    platformItem.createSpan({ cls: "syncthing-diagnostic-value", text: `${process.platform} ${process.arch}` });
    const nodeItem = diagnostics.createDiv("syncthing-diagnostic-item");
    nodeItem.createSpan({ cls: "syncthing-diagnostic-label", text: "Node.js:" });
    nodeItem.createSpan({ cls: "syncthing-diagnostic-value", text: process.version });
    const pluginItem = diagnostics.createDiv("syncthing-diagnostic-item");
    pluginItem.createSpan({ cls: "syncthing-diagnostic-label", text: "Plugin Version:" });
    pluginItem.createSpan({ cls: "syncthing-diagnostic-value", text: "1.5.1" });
    const debugControls = diagnosticsSection.createDiv("syncthing-controls");
    const logsBtn = debugControls.createEl("button", {
      cls: "syncthing-btn secondary",
      text: "\u{1F4CB} View Logs"
    });
    logsBtn.addEventListener("click", () => {
      console.log("Syncthing Plugin Debug Info:", {
        settings: this.plugin.settings,
        executablePath: this.plugin.getSyncthingExecutablePath(),
        platform: process.platform,
        arch: process.arch
      });
      new import_obsidian.Notice("Debug info logged to console (F12)");
    });
    const testBtn = debugControls.createEl("button", {
      cls: "syncthing-btn secondary",
      text: "\u{1F9EA} Test Connection"
    });
    testBtn.addEventListener("click", async () => {
      try {
        const isRunning = await this.plugin.isSyncthingRunning();
        if (isRunning) {
          new import_obsidian.Notice("\u2705 Connection successful - Syncthing is running");
        } else {
          new import_obsidian.Notice("\u274C Connection failed - Syncthing not running");
        }
      } catch (error) {
        new import_obsidian.Notice(`\u274C Connection test failed: ${error.message}`);
      }
    });
  }
  renderAboutTab(container) {
    const aboutEl = container.createDiv("syncthing-about");
    aboutEl.createDiv({ cls: "syncthing-logo", text: "\u{1F504}" });
    aboutEl.createEl("h2", { cls: "syncthing-about-title", text: "Syncthing Launcher" });
    aboutEl.createDiv({
      cls: "syncthing-about-version",
      text: "Version 1.5.1"
    });
    aboutEl.createDiv({
      cls: "syncthing-about-description",
      text: "This plugin provides seamless integration between Obsidian and Syncthing, enabling you to automatically sync your vault across devices with Syncthing's peer-to-peer file synchronization."
    });
    const linksEl = aboutEl.createDiv("syncthing-links");
    const githubLink = linksEl.createEl("a", {
      cls: "syncthing-link",
      text: "\u{1F4DA} GitHub Repository",
      href: "#"
    });
    githubLink.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://github.com/LBF38/obsidian-syncthing-integration", "_blank");
    });
    const syncthingLink = linksEl.createEl("a", {
      cls: "syncthing-link",
      text: "\u{1F310} Syncthing.net",
      href: "#"
    });
    syncthingLink.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://syncthing.net", "_blank");
    });
    const docsLink = linksEl.createEl("a", {
      cls: "syncthing-link",
      text: "\u{1F4D6} Documentation",
      href: "#"
    });
    docsLink.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://docs.syncthing.net", "_blank");
    });
    const featuresSection = container.createDiv("syncthing-section");
    featuresSection.createEl("h3", { cls: "syncthing-section-title", text: "\u2728 Features" });
    const featuresList = featuresSection.createEl("ul");
    const features = [
      "Automatic Syncthing download and installation",
      "Cross-platform support (Windows, macOS, Linux)",
      "Configurable auto-start with Obsidian",
      "Web UI integration for advanced configuration",
      "Real-time status monitoring",
      "Mobile mode for remote connections",
      "Docker support for containerized deployment"
    ];
    features.forEach((feature) => {
      featuresList.createEl("li", { text: feature });
    });
  }
  async updateStatus() {
    try {
      const isRunning = await this.plugin.isSyncthingRunning();
      this.updateStatusDisplay(isRunning ? "running" : "stopped");
    } catch (error) {
      this.updateStatusDisplay("unknown");
    }
  }
  updateStatusDisplay(status) {
    const indicator = this.containerEl.querySelector(".syncthing-status-indicator");
    if (indicator) {
      indicator.className = `syncthing-status-indicator ${status}`;
      indicator.textContent = status === "running" ? "Running" : status === "stopped" ? "Stopped" : "Unknown";
    }
  }
  startAutoRefresh() {
    this.stopAutoRefresh();
    this.refreshInterval = setInterval(() => {
      if (this.activeTab === "overview") {
        this.updateStatus();
      }
    }, 1e4);
  }
  stopAutoRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
  hide() {
    this.stopAutoRefresh();
    super.hide();
  }
};
