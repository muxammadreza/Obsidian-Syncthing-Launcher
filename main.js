/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tree-kill/index.js
var require_tree_kill = __commonJS({
  "node_modules/tree-kill/index.js"(exports, module2) {
    "use strict";
    var childProcess = require("child_process");
    var spawn2 = childProcess.spawn;
    var exec2 = childProcess.exec;
    module2.exports = function(pid, signal, callback) {
      if (typeof signal === "function" && callback === void 0) {
        callback = signal;
        signal = void 0;
      }
      pid = parseInt(pid);
      if (Number.isNaN(pid)) {
        if (callback) {
          return callback(new Error("pid must be a number"));
        } else {
          throw new Error("pid must be a number");
        }
      }
      var tree = {};
      var pidsToProcess = {};
      tree[pid] = [];
      pidsToProcess[pid] = 1;
      switch (process.platform) {
        case "win32":
          exec2("taskkill /pid " + pid + " /T /F", callback);
          break;
        case "darwin":
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn2("pgrep", ["-P", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
        default:
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn2("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
      }
    };
    function killAll(tree, signal, callback) {
      var killed = {};
      try {
        Object.keys(tree).forEach(function(pid) {
          tree[pid].forEach(function(pidpid) {
            if (!killed[pidpid]) {
              killPid(pidpid, signal);
              killed[pidpid] = 1;
            }
          });
          if (!killed[pid]) {
            killPid(pid, signal);
            killed[pid] = 1;
          }
        });
      } catch (err) {
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        return callback();
      }
    }
    function killPid(pid, signal) {
      try {
        process.kill(parseInt(pid, 10), signal);
      } catch (err) {
        if (err.code !== "ESRCH")
          throw err;
      }
    }
    function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
      var ps = spawnChildProcessesList(parentPid);
      var allData = "";
      ps.stdout.on("data", function(data) {
        var data = data.toString("ascii");
        allData += data;
      });
      var onClose = function(code) {
        delete pidsToProcess[parentPid];
        if (code != 0) {
          if (Object.keys(pidsToProcess).length == 0) {
            cb();
          }
          return;
        }
        allData.match(/\d+/g).forEach(function(pid) {
          pid = parseInt(pid, 10);
          tree[parentPid].push(pid);
          tree[pid] = [];
          pidsToProcess[pid] = 1;
          buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
        });
      };
      ps.on("close", onClose);
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SyncthingLauncher
});
module.exports = __toCommonJS(main_exports);
var http = __toESM(require("http"));
var import_obsidian = require("obsidian");
var import_events = require("events");
var spawn;
var exec;
var readFileSync;
var writeFileSync;
try {
  const childProcess = require("child_process");
  const fs = require("fs");
  spawn = childProcess.spawn;
  exec = childProcess.exec;
  readFileSync = fs.readFileSync;
  writeFileSync = fs.writeFileSync;
} catch (error) {
  console.log("Desktop-only modules not available (mobile platform detected)");
}
var DEFAULT_SETTINGS = {
  syncthingApiKey: "",
  vaultFolderID: "",
  startOnObsidianOpen: false,
  stopOnObsidianClose: false,
  useDocker: false,
  remoteUrl: "http://127.0.0.1:8384",
  mobileMode: false
};
var SyncthingMonitor = class extends import_events.EventEmitter {
  constructor() {
    super(...arguments);
    this.token = null;
    this.timeout = 1;
    this.isTokenSet = false;
    this.baseUrl = "http://127.0.0.1:8384";
    this.status = "idle";
    this.connectedDevicesCount = 0;
    this.availableDevices = 0;
    this.setStatusIcon = () => {
    };
  }
  startMonitoring(settings, setStatusIcon, baseUrl) {
    this.token = settings.syncthingApiKey;
    this.timeout = 1;
    this.setStatusIcon = setStatusIcon;
    this.isTokenSet = !!settings.syncthingApiKey;
    this.baseUrl = baseUrl;
    if (this.isTokenSet) {
      this.poll();
      this.checkConnections();
    } else {
      this.status = "API key not set";
      this.setStatusIcon("\u274C");
      this.emit("status-update", {
        status: this.status,
        fileCompletion: NaN,
        globalItems: NaN,
        needItems: NaN,
        connectedDevicesCount: NaN,
        availableDevices: NaN
      });
    }
  }
  stopMonitoring() {
    if (this.pollingTimeoutId) {
      clearTimeout(this.pollingTimeoutId);
      this.pollingTimeoutId = void 0;
    }
    this.lastEventId = void 0;
    this.status = "stopped";
    this.emit("disconnected");
  }
  poll() {
    var _a;
    const lastId = (_a = this.lastEventId) != null ? _a : 0;
    if (!this.token) {
      console.error("Syncthing API token is not set. Cannot poll for events.");
      this.status = "API key not set";
      this.emit("status-update", {
        status: this.status,
        fileCompletion: NaN,
        globalItems: NaN,
        needItems: NaN,
        connectedDevicesCount: NaN,
        availableDevices: NaN
      });
      return;
    }
    const url = new URL(this.baseUrl);
    let hostname = url.hostname;
    if (hostname === "localhost" || hostname === "127.0.0.1") {
      hostname = "::1";
    }
    const options = {
      hostname,
      port: parseInt(url.port) || 8384,
      path: `/rest/events?since=${lastId}&timeout=${this.timeout}`,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    };
    const req = http.request(options, (res) => {
      let body = "";
      res.on("data", (chunk) => {
        body += chunk;
      });
      res.on("end", () => {
        var _a2;
        const csrfErrorRegex = /CSRF Error/i;
        if (res.statusCode === 401 || csrfErrorRegex.test(body)) {
          console.error("Syncthing API key is invalid (401 Unauthorized or CSRF Error).");
          this.status = "Invalid API key";
          this.setStatusIcon("\u274C");
          this.emit("status-update", {
            status: this.status,
            fileCompletion: NaN,
            globalItems: NaN,
            needItems: NaN,
            connectedDevicesCount: NaN,
            availableDevices: NaN
          });
          this.pollingTimeoutId = setTimeout(() => this.poll(), 5e3);
          return;
        }
        try {
          const events = JSON.parse(body);
          if (Array.isArray(events)) {
            for (const event of events) {
              this.lastEventId = Math.max((_a2 = this.lastEventId) != null ? _a2 : 0, event.id);
              this.processEvent(event);
            }
          }
        } catch (err) {
          console.error("Failed to parse Syncthing events or unexpected response:", err);
        } finally {
          this.checkConnections();
          this.emit("status-update", {
            status: this.status,
            fileCompletion: this.fileCompletion,
            globalItems: this.globalItems,
            needItems: this.needItems,
            connectedDevicesCount: this.connectedDevicesCount,
            availableDevices: this.availableDevices
          });
          this.pollingTimeoutId = setTimeout(() => this.poll(), this.timeout * 1e3);
        }
      });
    });
    req.on("error", (err) => {
      console.error("Syncthing connection error:", err);
      this.status = "Connection error";
      this.setStatusIcon("\u274C");
      this.pollingTimeoutId = setTimeout(() => this.poll(), 5e3);
    });
    req.end();
  }
  processEvent(event) {
    console.log("Syncthing event:", event.type, event.data);
    switch (event.type) {
      case "FolderCompletion":
        const completion = event.data.completion;
        const globalItems = event.data.globalItems;
        const needItems = event.data.needItems;
        this.fileCompletion = completion;
        this.globalItems = globalItems;
        this.needItems = needItems;
        if (completion !== 100) {
          this.setStatusIcon("\u{1F7E1}");
        } else {
          this.setStatusIcon("\u{1F7E2}");
        }
        break;
      case "StateChanged":
        const newStatus = event.data.to;
        this.status = newStatus;
        if (newStatus === "scanning") {
          this.setStatusIcon("\u{1F7E1}");
        } else if (newStatus === "idle") {
          this.setStatusIcon("\u{1F7E2}");
        }
        break;
      case "DeviceDisconnected":
        this.setStatusIcon("\u{1F534}");
        this.status = "Device disconnected";
        break;
      case "DeviceConnected":
        this.setStatusIcon("\u{1F7E2}");
        this.status = "Device connected";
        break;
      default:
        break;
    }
  }
  checkConnections() {
    if (!this.token) {
      console.error("Syncthing API token is not set. Cannot check connections.");
      this.status = "API key not set";
      this.emit("status-update", {
        status: this.status,
        fileCompletion: NaN,
        globalItems: NaN,
        needItems: NaN,
        connectedDevicesCount: NaN,
        availableDevices: NaN
      });
      return;
    }
    const url = new URL(this.baseUrl);
    let hostname = url.hostname;
    if (hostname === "localhost" || hostname === "127.0.0.1") {
      hostname = "::1";
    }
    const options = {
      hostname,
      port: parseInt(url.port) || 8384,
      path: "/rest/system/connections",
      method: "GET",
      headers: {
        "Authorization": `Bearer ${this.token}`
      }
    };
    const req = http.request(options, (res) => {
      let body = "";
      res.on("data", (chunk) => {
        body += chunk;
      });
      res.on("end", () => {
        const csrfErrorRegex = /CSRF Error/i;
        if (res.statusCode === 401 || csrfErrorRegex.test(body)) {
          console.error("Syncthing API key is invalid (401 Unauthorized or CSRF Error).");
          this.status = "Invalid API key";
          return;
        }
        try {
          const data = JSON.parse(body);
          const connectionsArray = Object.values(data.connections);
          this.availableDevices = connectionsArray.length;
          this.connectedDevicesCount = connectionsArray.filter((conn) => conn.connected).length;
          if (this.connectedDevicesCount === 0) {
            this.setStatusIcon("\u{1F534}");
            this.status = "No devices connected";
          } else if (this.status === "idle") {
            this.setStatusIcon("\u{1F7E2}");
          }
        } catch (err) {
          console.error("Failed to parse Syncthing connections or unexpected response:", err);
        } finally {
          this.emit("status-update", {
            status: this.status,
            fileCompletion: this.fileCompletion,
            globalItems: this.globalItems,
            needItems: this.needItems,
            connectedDevicesCount: this.connectedDevicesCount,
            availableDevices: this.availableDevices
          });
        }
      });
    });
    req.on("error", (err) => {
      console.error("Syncthing connections API error:", err);
    });
    req.end();
  }
  /**
   * Check if Syncthing is running using Node.js HTTP requests
   */
  async isSyncthingRunning() {
    return new Promise((resolve) => {
      const url = new URL(this.baseUrl);
      let hostname = url.hostname;
      if (hostname === "localhost" || hostname === "127.0.0.1") {
        hostname = "::1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: "/",
        method: "GET",
        timeout: 2e3
        // 2 second timeout
      };
      const req = http.request(options, (res) => {
        resolve(true);
      });
      req.on("error", (err) => {
        console.log("Syncthing connection error:", err.message);
        if (err.message.includes("ECONNREFUSED")) {
          resolve(false);
        } else {
          resolve(false);
        }
      });
      req.on("timeout", () => {
        req.destroy();
        resolve(false);
      });
      req.end();
    });
  }
};
var UPDATE_INTERVAL = 5e3;
var SYNCTHING_CORS_PROXY_CONTAINER_URL = "http://127.0.0.1:8380/";
var SyncthingLauncher = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.vaultPath = "";
    this.vaultName = "";
    this.isMobile = false;
    this.syncthingInstance = null;
    this.syncthingLastSyncDate = "no data";
    this.statusBarConnectionIconItem = this.addStatusBarItem();
    this.statusBarLastSyncTextItem = this.addStatusBarItem();
    this.setStatusIcon = (icon) => {
      if (this.statusBarConnectionIconItem) {
        this.statusBarConnectionIconItem.setText(icon);
        let tooltip = `Syncthing: ${this.monitor.status}`;
        if (this.monitor.availableDevices > 0) {
          tooltip += `
Devices: ${this.monitor.connectedDevicesCount}/${this.monitor.availableDevices}`;
        }
        if (this.monitor.fileCompletion !== void 0 && !isNaN(this.monitor.fileCompletion)) {
          tooltip += `
Sync: ${this.monitor.fileCompletion.toFixed(1)}%`;
        }
        this.statusBarConnectionIconItem.setAttribute("title", tooltip);
        this.statusBarConnectionIconItem.ariaLabel = tooltip;
      }
    };
  }
  async onload() {
    var _a, _b, _c;
    await this.loadSettings();
    this.monitor = new SyncthingMonitor();
    this.isMobile = this.detectMobilePlatform();
    if (this.isMobile && !this.settings.mobileMode) {
      this.settings.mobileMode = true;
      await this.saveSettings();
    }
    let adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      this.vaultPath = adapter.getBasePath();
      this.vaultName = adapter.getName();
    }
    (_a = this.statusBarConnectionIconItem) == null ? void 0 : _a.addClasses(["status-bar-item", "status-icon"]);
    (_b = this.statusBarConnectionIconItem) == null ? void 0 : _b.setAttribute("data-tooltip-position", "top");
    (_c = this.statusBarConnectionIconItem) == null ? void 0 : _c.onClickEvent((event) => {
      this.monitor.isSyncthingRunning().then(
        (isRunning) => {
          if (!isRunning) {
            new import_obsidian.Notice("Starting Syncthing!");
            this.startSyncthing();
          } else {
            new import_obsidian.Notice("Stopping Syncthing!");
            this.stopSyncthing();
          }
        }
      );
    });
    this.startStatusMonitoring();
    this.updateStatusBar();
    this.registerInterval(
      window.setInterval(() => this.updateLastSyncDate(), UPDATE_INTERVAL)
    );
    this.addSettingTab(new SettingTab(this.app, this));
    if (this.settings.startOnObsidianOpen) {
      this.startSyncthing();
    }
    window.addEventListener("beforeunload", this.handleBeforeUnload.bind(this));
  }
  onunload() {
    window.removeEventListener("beforeunload", this.handleBeforeUnload.bind(this));
    this.monitor.stopMonitoring();
  }
  // --- Logic ---
  startStatusMonitoring() {
    if (!this.settings.syncthingApiKey) {
      this.setStatusIcon("\u274C");
      console.log("No API key set, skipping status monitoring");
      return;
    }
    const baseUrl = this.getSyncthingURL();
    this.monitor.startMonitoring(this.settings, this.setStatusIcon, baseUrl);
    this.monitor.on("status-update", (data) => {
      this.updateStatusBarFromMonitor(data);
    });
  }
  updateStatusBarFromMonitor(data) {
    if (data.status === "Invalid API key") {
      this.setStatusIcon("\u274C");
    } else if (data.status === "API key not set") {
      this.setStatusIcon("\u274C");
    } else if (data.connectedDevicesCount === 0) {
      this.setStatusIcon("\u{1F534}");
    } else if (data.status === "scanning") {
      this.setStatusIcon("\u{1F7E1}");
    } else if (data.fileCompletion !== void 0 && data.fileCompletion < 100) {
      this.setStatusIcon("\u{1F7E1}");
    } else {
      this.setStatusIcon("\u{1F7E2}");
    }
  }
  handleBeforeUnload(event) {
    if (this.settings.stopOnObsidianClose) {
      this.stopSyncthing();
    }
  }
  async startSyncthing() {
    this.monitor.isSyncthingRunning().then(async (isRunning) => {
      if (isRunning) {
        console.log("Syncthing is already running");
        return;
      }
      if (this.isMobile || this.settings.mobileMode) {
        new import_obsidian.Notice("Mobile mode: Please connect to an existing Syncthing instance via Remote URL in settings", 5e3);
        return;
      }
      if (this.settings.useDocker) {
        if (this.checkDockerStatus()) {
          new import_obsidian.Notice("Starting Docker");
          this.startSyncthingDockerStack();
        }
      } else {
        if (!spawn) {
          new import_obsidian.Notice("Local Syncthing execution not available on mobile platforms", 5e3);
          return;
        }
        const executableExists = await this.checkExecutableExists();
        if (!executableExists) {
          new import_obsidian.Notice("Syncthing executable missing. Attempting to download...", 5e3);
          const downloadSuccess = await this.downloadSyncthingExecutable();
          if (!downloadSuccess) {
            new import_obsidian.Notice("Auto-download failed. Please manually download syncthing-executables.tar.gz from the GitHub release or enable Mobile Mode.", 15e3);
            return;
          }
        }
        const executablePath = this.getSyncthingExecutablePath();
        const configDir = `${this.getPluginAbsolutePath()}syncthing-config`;
        if (typeof require !== "undefined") {
          const fs = require("fs");
          if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
          }
        }
        let port = "8384";
        if (this.settings.remoteUrl) {
          const urlMatch = this.settings.remoteUrl.match(/^https?:\/\/(127\.0\.0\.1|localhost):(\d+)/);
          if (urlMatch) {
            port = urlMatch[2];
            console.log(`Using custom port ${port} from remoteUrl: ${this.settings.remoteUrl}`);
          } else {
            console.log(`RemoteUrl set but not localhost, using default port 8384: ${this.settings.remoteUrl}`);
          }
        } else {
          console.log(`No remoteUrl set, using default port 8384`);
        }
        await this.ensureConfigForPort(configDir, port);
        if (this.syncthingInstance) {
          console.log("Stopping existing Syncthing instance before starting with new configuration...");
          await this.stopSyncthing();
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
        const args = [
          "--home",
          configDir,
          "--no-browser",
          "--gui-address",
          `127.0.0.1:${port}`
        ];
        console.log(`Starting Syncthing with args: ${args.join(" ")}`);
        this.syncthingInstance = spawn(executablePath, args);
        this.syncthingInstance.stdout.on("data", (data) => {
          console.log(`stdout: ${data}`);
        });
        this.syncthingInstance.stderr.on("data", (data) => {
          console.error(`stderr: ${data}`);
        });
        this.syncthingInstance.on("exit", (code) => {
          console.log(`child process exited with code ${code}`);
        });
        setTimeout(() => {
          this.startStatusMonitoring();
        }, 2e3);
      }
    });
  }
  stopSyncthing() {
    var _a;
    this.monitor.stopMonitoring();
    if (this.isMobile || this.settings.mobileMode) {
      console.log("Mobile mode: No local Syncthing to stop");
      return;
    }
    if (this.settings.useDocker) {
      if (!exec) {
        console.log("Docker operations not available on mobile platforms");
        return;
      }
      const dockerRunCommand = [
        `docker compose`,
        `-f ${this.getPluginAbsolutePath()}docker/docker-compose.yaml`,
        `stop`
      ];
      exec(dockerRunCommand.join(" "), (error, stdout, stderr) => {
        if (error) {
          console.error("Error:", error.message);
          return false;
        }
        if (stderr) {
          console.log(stderr);
          return false;
        }
        console.log("Output:", stdout);
      });
    } else {
      if (!this.syncthingInstance) {
        console.log("No local Syncthing instance to stop");
        return;
      }
      const pid = (_a = this.syncthingInstance) == null ? void 0 : _a.pid;
      if (pid !== void 0) {
        var kill = require_tree_kill();
        kill(pid, "SIGTERM", (err) => {
          if (err) {
            console.error("Failed to kill process tree:", err);
          } else {
            console.log("Process tree killed successfully.");
          }
        });
      }
    }
  }
  /**
   * Use Node.js HTTP for config operations to match the monitoring approach
   */
  async pauseSyncthing() {
    try {
      const baseUrl = this.getSyncthingURL();
      const config = await this.getSyncthingConfig();
      for (const folder of config.folders) {
        folder.paused = true;
      }
      return await this.updateSyncthingConfig(config);
    } catch (error) {
      console.error("Failed to pause Syncthing:", error);
      return false;
    }
  }
  async resumeSyncthing() {
    try {
      const baseUrl = this.getSyncthingURL();
      const config = await this.getSyncthingConfig();
      for (const folder of config.folders) {
        folder.paused = false;
      }
      return await this.updateSyncthingConfig(config);
    } catch (error) {
      console.error("Failed to resume Syncthing:", error);
      return false;
    }
  }
  /**
   * Get Syncthing config using Node.js HTTP
   */
  async getSyncthingConfig() {
    return new Promise((resolve, reject) => {
      if (!this.settings.syncthingApiKey) {
        reject(new Error("API key not set"));
        return;
      }
      const url = new URL(this.getSyncthingURL());
      let hostname = url.hostname;
      if (hostname === "localhost" || hostname === "127.0.0.1") {
        hostname = "::1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: "/rest/config",
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.syncthingApiKey}`
        }
      };
      const req = http.request(options, (res) => {
        let body = "";
        res.on("data", (chunk) => body += chunk);
        res.on("end", () => {
          try {
            resolve(JSON.parse(body));
          } catch (error) {
            reject(error);
          }
        });
      });
      req.on("error", reject);
      req.end();
    });
  }
  /**
   * Update Syncthing config using Node.js HTTP
   */
  async updateSyncthingConfig(config) {
    return new Promise((resolve) => {
      if (!this.settings.syncthingApiKey) {
        resolve(false);
        return;
      }
      const url = new URL(this.getSyncthingURL());
      const postData = JSON.stringify(config);
      let hostname = url.hostname;
      if (hostname === "localhost" || hostname === "127.0.0.1") {
        hostname = "::1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: "/rest/config",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.syncthingApiKey}`,
          "Content-Type": "application/json",
          "Content-Length": Buffer.byteLength(postData)
        }
      };
      const req = http.request(options, (res) => {
        resolve(res.statusCode === 200);
      });
      req.on("error", () => resolve(false));
      req.write(postData);
      req.end();
    });
  }
  async startSyncthingDockerStack() {
    if (!exec) {
      new import_obsidian.Notice("Docker operations not available on mobile platforms", 5e3);
      return;
    }
    this.updateEnvFile({
      VAULT_PATH: `${this.vaultPath}`,
      SYNCTHING_CONFIG_PATH: `${this.vaultPath}/.obsidian/syncthing_config`
    });
    const dockerRunCommand = [
      `docker compose`,
      `-f ${this.getPluginAbsolutePath()}docker/docker-compose.yaml`,
      `up`,
      `-d`
    ];
    exec(dockerRunCommand.join(" "), (error, stdout, stderr) => {
      if (error) {
        console.error("Error:", error.message);
        return false;
      }
      if (stderr) {
        console.log(stderr);
        return false;
      }
      console.log("Output:", stdout);
    });
  }
  updateEnvFile(vars) {
    if (!writeFileSync || !readFileSync) {
      console.log("File system operations not available on mobile platform");
      return;
    }
    const filePath = `${this.getPluginAbsolutePath()}docker/.env`;
    let content = readFileSync(filePath, "utf8");
    Object.entries(vars).forEach(([key, value]) => {
      const regex = new RegExp(`^${key}=.*`, "m");
      content = content.replace(regex, `${key}=${value}`);
    });
    writeFileSync(filePath, content, "utf8");
  }
  async ensureConfigForPort(configDir, port) {
    if (typeof require !== "undefined") {
      const fs = require("fs");
      const path = require("path");
      const portFile = path.join(configDir, ".syncthing-port");
      let storedPort = "";
      if (fs.existsSync(portFile)) {
        try {
          storedPort = fs.readFileSync(portFile, "utf8").trim();
        } catch (error) {
          console.log("Could not read stored port file:", error);
        }
      }
      if (storedPort && storedPort !== port) {
        console.log(`Port changed from ${storedPort} to ${port}, clearing Syncthing config...`);
        try {
          const files = fs.readdirSync(configDir);
          for (const file of files) {
            const filePath = path.join(configDir, file);
            const stat = fs.statSync(filePath);
            if (stat.isFile()) {
              fs.unlinkSync(filePath);
              console.log(`Removed config file: ${file}`);
            } else if (stat.isDirectory() && file !== "." && file !== "..") {
              fs.rmSync(filePath, { recursive: true, force: true });
              console.log(`Removed config directory: ${file}`);
            }
          }
        } catch (error) {
          console.log("Error clearing config directory:", error);
        }
      }
      try {
        fs.writeFileSync(portFile, port, "utf8");
        console.log(`Stored current port: ${port}`);
      } catch (error) {
        console.log("Could not store port file:", error);
      }
    }
  }
  getSyncthingURL() {
    if (this.isMobile || this.settings.mobileMode) {
      console.log(`Using mobile/remote URL: ${this.settings.remoteUrl}`);
      return this.settings.remoteUrl;
    }
    if (this.settings.useDocker) {
      console.log(`Using Docker URL: ${SYNCTHING_CORS_PROXY_CONTAINER_URL}`);
      return SYNCTHING_CORS_PROXY_CONTAINER_URL;
    } else {
      if (this.settings.remoteUrl) {
        console.log(`Using configured remoteUrl: ${this.settings.remoteUrl}`);
        return this.settings.remoteUrl;
      }
      console.log(`Using default localhost URL: http://127.0.0.1:8384`);
      return "http://127.0.0.1:8384";
    }
  }
  /**
   * Use the monitor's improved status detection
   */
  async isSyncthingRunning() {
    return await this.monitor.isSyncthingRunning();
  }
  checkDockerStatus() {
    if (!exec) {
      console.log("Docker operations not available on mobile platforms");
      return false;
    }
    exec("docker ps", (error, stdout, stderr) => {
      if (error) {
        console.error("Error:", error.message);
        return false;
      }
      if (stderr) {
        console.error("Error:", stderr);
        return false;
      }
      console.log("Output:", stdout);
    });
    return true;
  }
  updateStatusBar() {
    this.monitor.isSyncthingRunning().then((isRunning) => {
      if (this.statusBarConnectionIconItem) {
        if (!isRunning) {
          this.statusBarConnectionIconItem.setText("\u26AB");
          this.statusBarConnectionIconItem.ariaLabel = "Click to start Syncthing";
        }
        this.statusBarConnectionIconItem.addClasses(["plugin-editor-status", "mouse-pointer"]);
      }
    });
  }
  /**
   * Update last sync date - called periodically
   */
  updateLastSyncDate() {
    this.getLastSyncDate().then((lastSyncDate) => {
      if (lastSyncDate !== null) {
        const optionsDate = { day: "2-digit", month: "2-digit", year: "2-digit" };
        const formattedDate = lastSyncDate.toLocaleDateString("en-GB", optionsDate).split("/").join(".");
        const optionsTime = { hour: "2-digit", minute: "2-digit", hour12: false };
        const formattedTime = lastSyncDate.toLocaleTimeString("en-GB", optionsTime);
        this.syncthingLastSyncDate = `${formattedDate} ${formattedTime}`;
      } else {
        this.syncthingLastSyncDate = "no data";
      }
      if (this.statusBarLastSyncTextItem) {
        this.statusBarLastSyncTextItem.setText(`Last sync: ${this.syncthingLastSyncDate}`);
      }
    });
  }
  async checkExecutableExists() {
    if (!this.app.vault.adapter || this.isMobile || this.settings.mobileMode) {
      return true;
    }
    try {
      const executablePath = this.getSyncthingExecutablePath();
      if (typeof require !== "undefined") {
        try {
          const fs = require("fs");
          return fs.existsSync(executablePath);
        } catch (error) {
          console.error("Error checking file with fs:", error);
        }
      }
      return false;
    } catch (error) {
      console.error("Error checking executable:", error);
      return false;
    }
  }
  /**
   * Download Syncthing executable using official GitHub releases API
   */
  async downloadSyncthingExecutable() {
    try {
      new import_obsidian.Notice("Fetching latest Syncthing release information...", 5e3);
      const releaseInfo = await this.getLatestSyncthingRelease();
      if (!releaseInfo) {
        new import_obsidian.Notice("Failed to fetch latest Syncthing release information", 8e3);
        return false;
      }
      let platformPattern;
      let expectedExecutableName;
      if (process.platform === "win32") {
        const arch = process.arch === "x64" ? "amd64" : process.arch === "arm64" ? "arm64" : "386";
        platformPattern = `syncthing-windows-${arch}-v${releaseInfo.version}`;
        expectedExecutableName = "syncthing.exe";
      } else if (process.platform === "darwin") {
        if (process.arch === "arm64") {
          platformPattern = `syncthing-macos-arm64-v${releaseInfo.version}`;
        } else if (process.arch === "x64") {
          platformPattern = `syncthing-macos-amd64-v${releaseInfo.version}`;
        } else {
          platformPattern = `syncthing-macos-universal-v${releaseInfo.version}`;
        }
        expectedExecutableName = "syncthing";
      } else {
        const arch = process.arch === "x64" ? "amd64" : process.arch === "arm64" ? "arm64" : process.arch === "arm" ? "arm" : "386";
        platformPattern = `syncthing-linux-${arch}-v${releaseInfo.version}`;
        expectedExecutableName = "syncthing";
      }
      const asset = releaseInfo.assets.find(
        (asset2) => asset2.name.startsWith(platformPattern)
      );
      if (!asset) {
        new import_obsidian.Notice(`No Syncthing release found for ${process.platform} ${process.arch}. Available assets: ${releaseInfo.assets.map((a) => a.name).join(", ")}`, 1e4);
        return false;
      }
      new import_obsidian.Notice(`Downloading Syncthing ${releaseInfo.version} for ${process.platform} ${process.arch}... Please wait.`, 8e3);
      console.log(`Downloading Syncthing from: ${asset.browser_download_url}`);
      const archiveData = await this.downloadFile(asset.browser_download_url);
      if (!archiveData) {
        new import_obsidian.Notice("Failed to download Syncthing archive", 8e3);
        return false;
      }
      const success = await this.extractAndInstallSyncthing(archiveData, asset.name, expectedExecutableName);
      if (success) {
        new import_obsidian.Notice(`Syncthing ${releaseInfo.version} downloaded and installed successfully!`, 5e3);
        return true;
      } else {
        new import_obsidian.Notice("Failed to extract and install Syncthing executable", 8e3);
        return false;
      }
    } catch (error) {
      console.error("Failed to download Syncthing executable:", error);
      new import_obsidian.Notice(`Failed to download Syncthing executable: ${error.message}. Please download manually from GitHub release.`, 1e4);
      return false;
    }
  }
  /**
   * Get latest release information from Syncthing GitHub API
   */
  async getLatestSyncthingRelease() {
    return new Promise((resolve, reject) => {
      const https = require("https");
      const options = {
        hostname: "api.github.com",
        port: 443,
        path: "/repos/syncthing/syncthing/releases/latest",
        method: "GET",
        headers: {
          "User-Agent": "Obsidian-Syncthing-Launcher-Plugin"
        }
      };
      const req = https.request(options, (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          try {
            const releaseData = JSON.parse(data);
            if (res.statusCode !== 200) {
              reject(new Error(`GitHub API error: ${res.statusCode} - ${releaseData.message || "Unknown error"}`));
              return;
            }
            resolve({
              version: releaseData.tag_name.replace("v", ""),
              // Remove 'v' prefix
              assets: releaseData.assets,
              html_url: releaseData.html_url
            });
          } catch (error) {
            reject(new Error(`Failed to parse GitHub API response: ${error.message}`));
          }
        });
      });
      req.on("error", (error) => {
        reject(new Error(`Failed to fetch release info: ${error.message}`));
      });
      req.setTimeout(1e4, () => {
        req.destroy();
        reject(new Error("GitHub API request timeout"));
      });
      req.end();
    });
  }
  /**
   * Download a file using Node.js HTTPS
   */
  async downloadFile(url) {
    return new Promise((resolve) => {
      const https = require("https");
      const urlModule = require("url");
      const parsedUrl = urlModule.parse(url);
      const options = {
        hostname: parsedUrl.hostname,
        port: 443,
        path: parsedUrl.path,
        method: "GET",
        headers: {
          "User-Agent": "Obsidian-Syncthing-Launcher-Plugin"
        }
      };
      const req = https.request(options, (res) => {
        if (res.statusCode === 302 || res.statusCode === 301) {
          this.downloadFile(res.headers.location).then(resolve);
          return;
        }
        if (res.statusCode !== 200) {
          console.error(`Download failed with status ${res.statusCode}`);
          resolve(null);
          return;
        }
        const chunks = [];
        res.on("data", (chunk) => chunks.push(chunk));
        res.on("end", () => {
          resolve(Buffer.concat(chunks));
        });
      });
      req.on("error", (error) => {
        console.error("Download failed:", error);
        resolve(null);
      });
      req.setTimeout(6e4, () => {
        req.destroy();
        console.error("Download timeout");
        resolve(null);
      });
      req.end();
    });
  }
  /**
   * Extract and install Syncthing executable from downloaded archive
   */
  async extractAndInstallSyncthing(archiveData, archiveName, executableName) {
    if (typeof require === "undefined") {
      console.error("File system operations not available");
      return false;
    }
    try {
      const fs = require("fs");
      const path = require("path");
      const syncthingDir = path.join(this.getPluginAbsolutePath(), "syncthing");
      if (!fs.existsSync(syncthingDir)) {
        fs.mkdirSync(syncthingDir, { recursive: true });
      }
      const isZip = archiveName.endsWith(".zip");
      const isTarGz = archiveName.endsWith(".tar.gz");
      if (isZip) {
        const yauzl = await this.extractZip(archiveData, syncthingDir, executableName);
        return yauzl;
      } else if (isTarGz) {
        return await this.extractTarGz(archiveData, syncthingDir, executableName);
      } else {
        console.error("Unsupported archive format:", archiveName);
        return false;
      }
    } catch (error) {
      console.error("Failed to extract archive:", error);
      return false;
    }
  }
  /**
   * Extract ZIP archive (for Windows and macOS)
   */
  async extractZip(zipData, targetDir, executableName) {
    try {
      const fs = require("fs");
      const path = require("path");
      const { spawn: spawn2 } = require("child_process");
      const tempZipPath = path.join(targetDir, "temp-syncthing.zip");
      fs.writeFileSync(tempZipPath, zipData);
      return new Promise((resolve) => {
        let extractCommand;
        let extractArgs;
        if (process.platform === "win32") {
          extractCommand = "powershell";
          extractArgs = ["-Command", `Expand-Archive -Path "${tempZipPath}" -DestinationPath "${targetDir}" -Force`];
        } else {
          extractCommand = "unzip";
          extractArgs = ["-o", tempZipPath, "-d", targetDir];
        }
        const extractProcess = spawn2(extractCommand, extractArgs);
        extractProcess.on("close", (code) => {
          try {
            if (fs.existsSync(tempZipPath)) {
              fs.unlinkSync(tempZipPath);
            }
            if (code === 0) {
              this.findAndCopyExecutable(targetDir, executableName).then(resolve);
            } else {
              console.error("Extraction failed with code:", code);
              resolve(false);
            }
          } catch (error) {
            console.error("Post-extraction error:", error);
            resolve(false);
          }
        });
        extractProcess.on("error", (error) => {
          console.error("Extraction command failed:", error);
          try {
            if (fs.existsSync(tempZipPath)) {
              fs.unlinkSync(tempZipPath);
            }
          } catch (e) {
          }
          resolve(false);
        });
      });
    } catch (error) {
      console.error("ZIP extraction error:", error);
      return false;
    }
  }
  /**
   * Extract TAR.GZ archive (for Linux)
   */
  async extractTarGz(tarData, targetDir, executableName) {
    try {
      const fs = require("fs");
      const path = require("path");
      const { spawn: spawn2 } = require("child_process");
      const tempTarPath = path.join(targetDir, "temp-syncthing.tar.gz");
      fs.writeFileSync(tempTarPath, tarData);
      return new Promise((resolve) => {
        const extractProcess = spawn2("tar", ["-xzf", tempTarPath, "-C", targetDir]);
        extractProcess.on("close", (code) => {
          try {
            if (fs.existsSync(tempTarPath)) {
              fs.unlinkSync(tempTarPath);
            }
            if (code === 0) {
              this.findAndCopyExecutable(targetDir, executableName).then(resolve);
            } else {
              console.error("TAR extraction failed with code:", code);
              resolve(false);
            }
          } catch (error) {
            console.error("Post-extraction error:", error);
            resolve(false);
          }
        });
        extractProcess.on("error", (error) => {
          console.error("TAR extraction command failed:", error);
          try {
            if (fs.existsSync(tempTarPath)) {
              fs.unlinkSync(tempTarPath);
            }
          } catch (e) {
          }
          resolve(false);
        });
      });
    } catch (error) {
      console.error("TAR.GZ extraction error:", error);
      return false;
    }
  }
  /**
   * Find and copy the Syncthing executable to the final location
   */
  async findAndCopyExecutable(extractDir, executableName) {
    try {
      const fs = require("fs");
      const path = require("path");
      const findExecutable = (dir) => {
        const items = fs.readdirSync(dir);
        for (const item of items) {
          const itemPath = path.join(dir, item);
          const stat = fs.statSync(itemPath);
          if (stat.isFile() && item === executableName) {
            return itemPath;
          } else if (stat.isDirectory()) {
            const found = findExecutable(itemPath);
            if (found)
              return found;
          }
        }
        return null;
      };
      const executablePath = findExecutable(extractDir);
      if (!executablePath) {
        console.error(`Executable ${executableName} not found in extracted archive`);
        return false;
      }
      let finalPath;
      if (process.platform === "win32") {
        finalPath = path.join(extractDir, "syncthing.exe");
      } else if (process.platform === "darwin") {
        finalPath = path.join(extractDir, "syncthing-macos");
      } else {
        finalPath = path.join(extractDir, "syncthing-linux");
      }
      fs.copyFileSync(executablePath, finalPath);
      if (process.platform !== "win32") {
        fs.chmodSync(finalPath, "755");
      }
      this.cleanupExtractedFiles(extractDir, path.basename(finalPath));
      console.log(`Syncthing executable installed to: ${finalPath}`);
      return true;
    } catch (error) {
      console.error("Failed to find and copy executable:", error);
      return false;
    }
  }
  /**
   * Clean up extracted files, keeping only the renamed executable
   */
  cleanupExtractedFiles(dir, keepFile) {
    try {
      const fs = require("fs");
      const path = require("path");
      const items = fs.readdirSync(dir);
      for (const item of items) {
        if (item === keepFile)
          continue;
        const itemPath = path.join(dir, item);
        const stat = fs.statSync(itemPath);
        if (stat.isDirectory()) {
          fs.rmSync(itemPath, { recursive: true, force: true });
        } else {
          fs.unlinkSync(itemPath);
        }
      }
    } catch (error) {
      console.error("Cleanup error (non-fatal):", error);
    }
  }
  detectMobilePlatform() {
    const platform = process.platform;
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
    const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    return isMobileUA || isTouchDevice && window.innerWidth < 1024;
  }
  getPluginAbsolutePath() {
    let basePath;
    if (this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = this.app.vault.adapter.getBasePath();
    } else {
      throw new Error("Cannot determine base path.");
    }
    const relativePath = `${this.app.vault.configDir}/plugins/${this.manifest.id}-${this.manifest.version}/`;
    return `${basePath}/${relativePath}`;
  }
  getSyncthingExecutablePath() {
    const pluginPath = this.getPluginAbsolutePath();
    if (process.platform === "win32") {
      return `${pluginPath}syncthing/syncthing.exe`;
    } else if (process.platform === "darwin") {
      return `${pluginPath}syncthing/syncthing-macos`;
    } else {
      return `${pluginPath}syncthing/syncthing-linux`;
    }
  }
  /**
   * Get the last sync date using Node.js HTTP
   */
  async getLastSyncDate() {
    return new Promise((resolve) => {
      if (!this.settings.syncthingApiKey || !this.settings.vaultFolderID) {
        resolve(null);
        return;
      }
      const url = new URL(this.getSyncthingURL());
      let hostname = url.hostname;
      if (hostname === "localhost" || hostname === "127.0.0.1") {
        hostname = "::1";
      }
      const options = {
        hostname,
        port: parseInt(url.port) || 8384,
        path: `/rest/db/status?folder=${this.settings.vaultFolderID}`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.syncthingApiKey}`
        }
      };
      const req = http.request(options, (res) => {
        let body = "";
        res.on("data", (chunk) => body += chunk);
        res.on("end", () => {
          try {
            const data = JSON.parse(body);
            if (data.stateChanged) {
              resolve(new Date(data.stateChanged));
            } else {
              resolve(null);
            }
          } catch (error) {
            console.error("Failed to parse sync date response:", error);
            resolve(null);
          }
        });
      });
      req.on("error", (error) => {
        console.error("Failed to get last sync date:", error);
        resolve(null);
      });
      req.end();
    });
  }
  // --- Settings ---
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.monitor.stopMonitoring();
    setTimeout(() => {
      this.startStatusMonitoring();
    }, 1e3);
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const statusSection = containerEl.createDiv();
    statusSection.createEl("h2", { text: "Syncthing Control Panel" });
    const statusSetting = new import_obsidian.Setting(statusSection).setName("Syncthing Status").setDesc("Current status of Syncthing service");
    const statusButton = statusSetting.addButton((button) => button.setButtonText("Check Status").setTooltip("Check if Syncthing is running").onClick(async () => {
      const isRunning = await this.plugin.isSyncthingRunning();
      const status = isRunning ? "\u2705 Running" : "\u274C Not running";
      new import_obsidian.Notice(`Syncthing status: ${status}`);
      statusIndicator.setText(status);
    }));
    const statusIndicator = statusSetting.settingEl.createSpan();
    statusIndicator.style.marginLeft = "10px";
    statusIndicator.style.fontWeight = "bold";
    statusIndicator.setText("\u2753 Unknown");
    setTimeout(async () => {
      try {
        const isRunning = await this.plugin.isSyncthingRunning();
        statusIndicator.setText(isRunning ? "\u2705 Running" : "\u274C Not running");
      } catch (error) {
        statusIndicator.setText("\u274C Error checking status");
      }
    }, 500);
    const updateStatusFromMonitor = (data) => {
      let statusText = "\u2753 Unknown";
      if (data.status === "Invalid API key") {
        statusText = "\u274C Invalid API key";
      } else if (data.status === "API key not set") {
        statusText = "\u274C API key not set";
      } else if (data.connectedDevicesCount === 0) {
        statusText = "\u{1F534} No devices connected";
      } else if (data.status === "scanning") {
        statusText = "\u{1F7E1} Scanning";
      } else if (data.fileCompletion !== void 0 && data.fileCompletion < 100) {
        statusText = `\u{1F7E1} Syncing (${data.fileCompletion.toFixed(1)}%)`;
      } else {
        statusText = "\u{1F7E2} Connected";
      }
      statusIndicator.setText(statusText);
    };
    this.plugin.monitor.on("status-update", updateStatusFromMonitor);
    new import_obsidian.Setting(statusSection).setName("Start Syncthing").setDesc("Start the Syncthing service").addButton((button) => button.setButtonText("Start").setTooltip("Start Syncthing service").onClick(async () => {
      try {
        await this.plugin.startSyncthing();
        new import_obsidian.Notice("Syncthing started successfully!");
        setTimeout(async () => {
          const isRunning = await this.plugin.isSyncthingRunning();
          statusIndicator.setText(isRunning ? "\u2705 Running" : "\u274C Not running");
        }, 2e3);
      } catch (error) {
        new import_obsidian.Notice(`Failed to start Syncthing: ${error.message}`);
      }
    }));
    new import_obsidian.Setting(statusSection).setName("Stop Syncthing").setDesc("Stop the Syncthing service").addButton((button) => button.setButtonText("Stop").setTooltip("Stop Syncthing service").onClick(async () => {
      try {
        await this.plugin.stopSyncthing();
        new import_obsidian.Notice("Syncthing stopped successfully!");
        statusIndicator.setText("\u274C Not running");
      } catch (error) {
        new import_obsidian.Notice(`Failed to stop Syncthing: ${error.message}`);
      }
    }));
    new import_obsidian.Setting(statusSection).setName("Restart Syncthing").setDesc("Restart the Syncthing service").addButton((button) => button.setButtonText("Restart").setTooltip("Restart Syncthing service").onClick(async () => {
      try {
        await this.plugin.stopSyncthing();
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        await this.plugin.startSyncthing();
        new import_obsidian.Notice("Syncthing restarted successfully!");
        setTimeout(async () => {
          const isRunning = await this.plugin.isSyncthingRunning();
          statusIndicator.setText(isRunning ? "\u2705 Running" : "\u274C Not running");
        }, 2e3);
      } catch (error) {
        new import_obsidian.Notice(`Failed to restart Syncthing: ${error.message}`);
      }
    }));
    new import_obsidian.Setting(statusSection).setName("Pause Syncthing").setDesc("Pause synchronization (keeps Syncthing running but stops syncing)").addButton((button) => button.setButtonText("Pause").setTooltip("Pause synchronization").onClick(async () => {
      try {
        const success = await this.plugin.pauseSyncthing();
        if (success) {
          new import_obsidian.Notice("Syncthing paused successfully!");
        } else {
          new import_obsidian.Notice("Failed to pause Syncthing");
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to pause Syncthing: ${error.message}`);
      }
    }));
    new import_obsidian.Setting(statusSection).setName("Resume Syncthing").setDesc("Resume synchronization after pausing").addButton((button) => button.setButtonText("Resume").setTooltip("Resume synchronization").onClick(async () => {
      try {
        const success = await this.plugin.resumeSyncthing();
        if (success) {
          new import_obsidian.Notice("Syncthing resumed successfully!");
        } else {
          new import_obsidian.Notice("Failed to resume Syncthing");
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to resume Syncthing: ${error.message}`);
      }
    }));
    const binarySection = containerEl.createDiv();
    binarySection.createEl("h2", { text: "Binary Management" });
    new import_obsidian.Setting(binarySection).setName("Check Executable").setDesc("Check if Syncthing executable exists and is accessible").addButton((button) => button.setButtonText("Check").setTooltip("Verify Syncthing executable").onClick(async () => {
      const exists = await this.plugin.checkExecutableExists();
      if (exists) {
        new import_obsidian.Notice("\u2705 Syncthing executable found and accessible");
      } else {
        new import_obsidian.Notice("\u274C Syncthing executable not found");
      }
    }));
    new import_obsidian.Setting(binarySection).setName("Download Executable").setDesc("Download the Syncthing executable for your platform").addButton((button) => button.setButtonText("Download").setTooltip("Download Syncthing binary").onClick(async () => {
      try {
        const success = await this.plugin.downloadSyncthingExecutable();
        if (success) {
          new import_obsidian.Notice("\u2705 Syncthing executable downloaded successfully!");
        } else {
          new import_obsidian.Notice("\u274C Failed to download Syncthing executable");
        }
      } catch (error) {
        new import_obsidian.Notice(`Download failed: ${error.message}`);
      }
    }));
    new import_obsidian.Setting(binarySection).setName("Open Syncthing GUI").setDesc("Open Syncthing web interface in browser").addButton((button) => button.setButtonText("Open GUI").setTooltip("Open Syncthing web interface").onClick(async () => {
      const url = this.plugin.getSyncthingURL();
      window.open(url, "_blank");
    }));
    new import_obsidian.Setting(binarySection).setName("Reset Configuration").setDesc("Reset Syncthing configuration (useful for first-time setup or fixing login issues)").addButton((button) => button.setButtonText("Reset Config").setTooltip("Delete Syncthing configuration to start fresh").onClick(async () => {
      try {
        await this.plugin.stopSyncthing();
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        if (typeof require !== "undefined") {
          const fs = require("fs");
          const path = require("path");
          const configDir = `${this.plugin.getPluginAbsolutePath()}syncthing-config`;
          if (fs.existsSync(configDir)) {
            fs.rmSync(configDir, { recursive: true, force: true });
            new import_obsidian.Notice("Syncthing configuration reset successfully! Start Syncthing to begin initial setup.");
          } else {
            new import_obsidian.Notice("No configuration found to reset.");
          }
        }
      } catch (error) {
        new import_obsidian.Notice(`Failed to reset configuration: ${error.message}`);
      }
    }));
    const configSection = containerEl.createDiv();
    configSection.createEl("h2", { text: "Configuration" });
    new import_obsidian.Setting(configSection).setName("Syncthing API key").setDesc("API key of Syncthing instance (in Syncthing GUI -> Actions -> Settings)").addText((text) => text.setPlaceholder("Enter Syncthing API key").setValue(this.plugin.settings.syncthingApiKey).onChange(async (value) => {
      this.plugin.settings.syncthingApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(configSection).setName("Vault folder ID").setDesc("ID of the folder in which the vault is stored (in Syncthing GUI -> Folders -> Vault folder)").addText((text) => text.setPlaceholder("Enter vault folder ID").setValue(this.plugin.settings.vaultFolderID).onChange(async (value) => {
      this.plugin.settings.vaultFolderID = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(configSection).setName("Start on Obsidian open").setDesc("Start Syncthing when Obsidian opens").addToggle((toggle) => toggle.setValue(this.plugin.settings.startOnObsidianOpen).onChange(async (value) => {
      this.plugin.settings.startOnObsidianOpen = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(configSection).setName("Stop on Obsidian close").setDesc("Stop Syncthing when Obsidian closes").addToggle((toggle) => toggle.setValue(this.plugin.settings.stopOnObsidianClose).onChange(async (value) => {
      this.plugin.settings.stopOnObsidianClose = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(configSection).setName("Mobile Mode").setDesc("Enable mobile mode to connect to remote Syncthing instead of running locally (auto-detected)").addToggle((toggle) => toggle.setValue(this.plugin.settings.mobileMode).onChange(async (value) => {
      this.plugin.settings.mobileMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(configSection).setName("Remote Syncthing URL").setDesc("URL of remote Syncthing instance (used in mobile mode or when connecting to remote server)").addText((text) => text.setPlaceholder("http://192.168.1.100:8384").setValue(this.plugin.settings.remoteUrl).onChange(async (value) => {
      this.plugin.settings.remoteUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(configSection).setName("Use Docker").setDesc("Run Syncthing in Docker container instead of running it locally (desktop only)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useDocker).onChange(async (value) => {
      this.plugin.settings.useDocker = value;
      await this.plugin.saveSettings();
    }));
  }
};
